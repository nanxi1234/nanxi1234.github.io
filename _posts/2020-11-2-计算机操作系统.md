---
title: 计算机操作系统
---
请打开左侧目录浏览！

# 虚拟化

	操作系统将物理资源(*如处理器、内存、磁盘*)转换为更通用的、更强大，更易于使用的虚拟形式。

## 虚拟化CPU

	操作系统将单个CPU转换成看似无限数量的CPU，从而使许多程序看似同时运行，这就是所谓的虚拟化CPU。

### 时分共享技术

	通过让一个进程只运行一个时间片，然后切换到其他进程，操作系统提供了存在多个虚拟CPU的假象。
	
	潜在的开销就是性能损失，因为如果CPU必须共享，每个进程的运行就会慢一些。
	
	通过允许资源由一个实体使用一小段时间，然后由另一个实体使用一小段时间，如此下去，所谓的资源(例如，CPU或则或网络链接)可以被许多人共享

  空分技术：资源在空间上被划分给需要使用它的人

## 虚拟化内存

  每个进程访问自己的私有虚拟地址空间，操作系统以某种方式映射到机器的物理内存上，一个正在运行的程序中的内存引用不会影响其他进程(*或操作系统本身*)的地址空间，对于正在运行的程序，他完全拥有自己的物理内存，也即，物理内存是操作系统的共享资源。

## 进程

  一个进程就是一个正在执行的程序。在任何时刻，我们都可以清点它在执行过程中访问或影响的系统的不同部分，从而概括一个进程

### 进程的机器状态

定义：程序在运行时可以读取或更新的内容。

  机器状态的组成部分：

- 内存：指令存在内存中。正在运行的程序读取和写入的数据也在内存中。因此进程可以访问的内存是该进程的一部分
- 寄存器：许多指令明确的读取或则更新寄存器，例如，程序计数器(PC)告诉我们程序即将执行哪个指令；类似的，栈指针和相关的帧指针用于管理函数参数栈，局部变量和返回地址。

### 进程创建

- 将代码和所有的静态数据(*例如初始化变量*)加载到内存中(*需要操作系统从磁盘中读取这些字节，并把他放在内存的某处*)，加载到进程的地址空间中。

- 创建和初始化栈以及执行与I/O设置相关的其他工作

- 启动程序，在入口处运行，即main()，通过跳转到main()例程，OS将CPU的控制权交给新创建的进程，程序开始执行

### 进程状态

-  运行
-  就绪
-  阻塞
                               
                           
<img src="https://cdn.jsdelivr.net/gh/nanxi1234/picture//2020/20201113180108.png" alt="09297314c4fd0855ef0a3aa14987314" style="zoom:67%;" />
  
从就绪到运行意味着该进程已经被调度，从运行转移到就绪意味着该进程已经取消调度。一旦进程被阻塞，OS将保持进程的这种状态，直到发生某种事件(例如，I/O完成)，此时，进程再次转入就绪状态
  
  例如：从磁盘读取数据或等待网络数据包时，进程会被阻塞。OS发现进程0不使用CPU并开始运行进程1。当进程1运行时，I/O完成(系统决定切不切回进程0)，将进程0移回就绪状态，最后，进程1结束，进程0运行，然后完成。
### 进程API

- fork()系统调用：用于创建新进程

- wait()系统调用：有时候我们需要一个进程在另一个进程之后运行，这时wait()就可以起作用，例如父进程延迟自己的执行，直到子进程执行完毕，当它结束时，wait()才返回执行父进程。

- exec()系统调用：这个系统调用可以让子进程执行与父进程不同的进程。

  ```c
  char *myargs[3];
  myargs[0]=strdup("wc");//program:"wc"(word count)
  mygrgs[1]=strup("p3.c");//argument:file to count
  myargs[2]=NULL;//marks end of array
  execpv(myargs[0],myargs);//runs word count 
  //进程调用execvp()来运行字符计数程序wc
  ```
		exec()会从可执行程序中加载代码和静态数据，并用它覆写自己的代码段(以及静态数据），堆、栈及其及其他内存空间也会被初始化。然后操作系统就执行该程序，将参数通过argv传递给该进程。因此，它没有创建新进程，而是直接将当前运行的程序替换为不同的运行程序。

这样设计API的原因：在fork()之后exec()之前，可以在运行新程序之前改变环境

## 机制：受限直接运行

- 时分共享：为了虚拟化CPU，操作系统要以某种方式让许多任务共享物理CPU，让他们看起来像是在同时运行：运行一个进程一段时间，然后运行另外一个进程，如此轮换，实现虚拟化。
- 虚拟化机制的一些挑战：
  1. 性能：如何在不增加系统开销的情况下实现虚拟化
  2. 控制权：如何有效地运行进程，同时保留对CPU的控制？
### 受限直接执行
  只需要在CPU上运行程序即可。因此当OS希望启动程序时，它会在进程列表中为其创建一个进程条目，为其分配一些内存，将程序代码(从磁盘)加载到内存中，找到入口点，跳转到那里，开始运行用户的代码。

  存在的问题：
  - 操作系统如何确保程序不做任何我们不希望他做的事
  - 如何切换进程，实现CPU的时分共享
      解决方法：
  1. 用户模式和内核模式
      执行系统调用的过程：
        用户模式->执行陷阱指令->内核模式->陷阱返回指令->用户模式


  陷阱如何知道在OS内运行哪些代码？

   通过在启动时设置陷阱表来实现。当机器启动时，他在内核模式下执行，因此可以根据需要自由配置机器硬件。操作系统要做的第一件事，就是告诉硬件在发生异常时需要运行哪些代码。


  2. 时钟中断
          时钟设备可以编程为每隔几毫秒产生一次中断。产生中断时，当前正在运行的进程停止，操作系统中预先配置的中断处理程序会运行，操作系统重新获得CPU的控制权，因此他可以做他想做的事：停止当前进程，并启动另一进程。
  3. 上下文切换
       操作系统要做的就是为当前正在执行的进程保留一些寄存器的值，并为即将执行的进程恢复一些寄存器的值
### 总结
 		LDE的基本思路：让你想运行的程序在CPU上运行，首先设置好硬件，以便在没有操作系统帮助的情况下限制进程可以执行的操作

## 进程调度

  		为什么需要进程调度？进程调度解决的是什么问题？
  进程调度回答的是：在特定的时间应该运行哪个进程的问题。

- 工作负载假设：
  一些与系统中运行的进程有关的假设
- 调度指标：
  周转时间、响应时间
### 多级反馈队列(Multi-level Feedback Queue)

		MLFQ中有许多独立的队列，每个队列都有不同的优先级。任何时刻，一个工作只能存在与一个队列中，MLFQ总是先执行优先级高的工作。每个队列中可能有许多个工作，因此具有相同的优先级，这时采用轮转调度。MLFQ调度策略根据观察到的行为调整他的优先级

  




