---
title: java虚拟机
tags:
 
---

[TOC]



###  java虚拟机的主要组成部分及其作用

- 类加载器：加载文件到内存
- 执行引擎：解释命令交由操作系统执行
- 本地库接口：融合不同的语言为java所用
- 运行时数据区：执行java程序过程中所管理的内存区域

#### 运行时数据区域
<img src="https://cdn.jsdelivr.net/gh/nanxi1234/nanxi1234.github.io/image/2021/20210828170932.jpg" alt="虚拟机组成" style="zoom:67%;" />

类的加载指的是将类的.class文件中的二进制数据读入到内存中，将其放在运行时数据区的方法区内，然后在堆区创建一个 java.lang.Class对象，用来封装类在方法区内的数据结构。

##### 程序计数器

是一块较小的内存空间，它可以看作当前线程所执行的字节码的行号指示器，字节码解释器的工作：

通过改变这个计数器的值来选取下一条所要执行的字节码指令。

由于Java的多线程是通过线程轮流切换，分配处理器执行时间的方式来实现的，为了线程切换之后能够恢复到正确的执行位置，每条线程都需要有自己的程序计数器，称这类内存区域为*线程私有内存*。

唯一一个没有OutOfMemoryError情况的区域

##### java虚拟机栈

虚拟机栈也是*线程私有*的，生命周期与线程相同，虚拟机栈描述的是**java方法执行的线程内存模型**，每个方法执行时，虚拟机会同步创造一个栈帧用于存储**局部变量表、操作数栈、动态连接、方法出口等信息**，每一个方法从被调用到执行完毕的过程中，对应一个个栈帧在虚拟机中入栈出栈的过程。

局部变量表存放了编译期可知的各种Java虚拟机基本数据类型：boolean、char、byte、long、short、int、String、double

64位的double和long类型的数据会占用两个变量槽，其余的数据类型只用一个

异常情况：如果线程请求的栈深度大于虚拟机所允许的深度，将会抛出StackOverFlowError异常；如果虚拟机的内存可以动态拓展，当栈无法申请到足够的内存时会抛出OutOfMemoryError异常。

##### 本地方法栈

JAVA方法是由JAVA编写的，编译成字节码，存储在class文件中

本地方法是由其它语言编写的，编译成和处理器相关的机器代码

和虚拟机栈所发挥的作用相似，区别在于虚拟机栈只为虚拟机所执行的java方法服务，而本地方法栈则是为虚拟机使用到的本地方法服务。

异常：和虚拟机栈一样

##### java堆

java堆是被所有线程共享的一块内存区，是虚拟机管理的内存之中最大的一块，此区域唯一的目的是**存放对象实例**，“几乎所有的对象都在这里分配内存”(栈上分配、标量替换使它没有那么绝对)

java堆是垃圾收集器管理的内存区域，，将java堆细分的目的在于更好地回收内存，或更快地分配内存。

java堆可以处于物理上不连续的内存空间中，但是在逻辑上应该被视为连续的，java堆可被设计为固定大小的，也可以是扩展的，现在主流的java虚拟机都是按照可扩展来实现的，如果内存不够时会抛出OutOfMemoryError。

##### 方法区

线程共享，用于**存储被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存**等数据。

不需要连续空间，可扩展，可以选择不实现垃圾收集，这个区域的回收目标主要是针对常量池的回收和对类型的卸载，但是回收条件较为苛刻，因此回收效果不好。如果内存不够时会抛出OutOfMemoryError。

##### 运行时常量池

方法区的一部分，常量池表：用于存放编译期生成的各种字面量与符号引用，这部分内容在类加载后存放到方法区的运行时常量之中。自JDK 7起，原先存放在永生代的常量池被移至堆中。

常量不一定只有在编译期才产生，运行期间也可以将新的常量放入池中。如果内存不够时会抛出OutOfMemoryError。

##### 直接内存

不属于虚拟机运行时数据区，本机直接内存的分配不会受java堆大小的影响，但会受到本机内存大小及处理器寻址空间的限制。

##### 说一下堆栈的区别

JVM 中堆和栈属于不同的内存区域，使用目的也不同。栈常用于保存方法帧和局部变量，而对象总是在堆上分配。栈通常都比堆小（栈的空间是连续的，分配的内存大小在编译器就确定了，堆的空间不连续,分配的内存大小在运行期确定），也不会在多个线程之间共享，而堆被整个 JVM 的所有线程共享。

## java虚拟机对象

### 对象的创建

![虚拟机中对象的创建流程](https://cdn.jsdelivr.net/gh/nanxi1234/nanxi1234.github.io/image/2021/20210622200300.jpg)

- 为对象分配内存

有两种方式：

1.指针碰撞（规则）：即所有用过的内存放在一边，而空闲的的放在另一边。分配内存时将位于中间的指针指示器向空闲的内存移动一段与对象大小相等的距离

2.空闲列表（非规整）：维护一个列表来记录那些内存是可用的，这样在分配的时候可以从列表中查询到足够大的内存分配给对象，并在分配后更新列表记录

- 对象创建的线程安全问题

① 对分配内存空间的动作进行同步处理：采用CAS+失败重试的方式保证更新操作的原子性。

②把内存分配的动作按照线程划分在不同空间进行，即每个线程在java堆中进行预先分配一小块内存，称为本地线程分配缓冲（Thread Local Allocation Buffer,TLAB）,哪个线程要分配内存先从缓冲区分配，只有本地缓冲区用完了，分配新的缓冲区时才需要同步锁定。

#### 对象的内存布局

对象在堆内存中的存储布局可以划分为三大部分：*对象头*，*实例数据*、*对齐填充*。

- 对象头：主要包括两部分信息，一是用于存储自身的运行时数据，一是类型指针(即对象指向它的类型元数据的指针，java虚拟机通过这个指针来确定该对象是哪个类的实例)
- 实例数据：对象真正存储的有效信息，即我们在代码中所定义的各种类型的字段内容
- 对齐填充：任何对象的大小必须是8的倍数，对象头已被设计为8的倍数，如果对象实例数据部分没有对齐的话，就需要通过对齐填充来补全。



####  对象的访问定位

由于reference类型在《java虚拟机规范》中只是一个指向对象的引用，并没有定义这个引用通过什么方式定位、访问堆中对象的具体位置，因此对象访问的工作应由虚拟机实现。目前主流的访问方式主要有使用句柄和直接指针两种。

- 句柄访问：java堆中划分出一块内存作为句柄池，reference中存储的就是对象的句柄地址，句柄包括对象实例数据与类型数据各自具体的地址信息。
- 直接指针访问：reference中存放的就是对象地址，少一次间接访问的开销

优缺点分析：

使用句柄访问的最大好处就是reference中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据的指针，reference不需要被修改。

直接指针的好处是能节省一次指针定位的时间。

## 垃圾收集器与内存分配策略

## 概述

为什么需要垃圾回收？

当垃圾收集成为系统达到更高并发量的瓶颈，就必须对这些“自动化的技术“实施必要的监控和调节

垃圾收集需要完成的三件事：

- 哪些内存需要被回收？

java堆和方法区，，因为这两个区域有着显著的不确定性，只有在运行期间，才能知道程序要创建哪些对象， 创造多少对象，这部分的内存的分配和回收是动态的，垃圾收集器所关注的正是这部分内存该如何管理。

- 什么时候回收？

在堆中存放着java世界的几乎所有对象实例，垃圾收集器在对堆进行回收时，第一件事情就是确定哪些对象还”存活“，哪些已经”死去“（即不可能再被任何途径使用的对象）。

  几种判断算法：

①引用计数：在对象中添加引用计数器，每当一个地方引用它时，计数器值就加一，引用失效，计数器值减一。缺点：需要配合大量的额外处理才能保证正确的工作。如无法通过此方法解决对象之间循环引用的问题。

②可达性分析算法

通过一系列称为”GC Roots“的根对象作为起始节点集，从这些结点开始，根据引用关系向下搜索，搜索过程所走过的路径称为引用链，如果某个对象到GC Roots的根对象间没有任何引用链相连，则证明此对象不能再被使用。（局部回收时）某个区域的对象完全有可能被位于堆中的其它区域的对象所引用，这时就需要将这些关联区域的对象一并加入到GC Root集合中去，这样才能保证可达性分析的正确性。

- 如何回收？



## 引用

引用的类型：

强引用、软引用、弱引用、虚引用

- 强引用：Object obj = New Object，这种引用关系，无论任何情况，只要存在，垃圾收集器就永远不会回收掉引用的对象。
- 软引用：描述一些还有用但非必要的对象；被软引用关联的对象在系统将要发生内存溢出之前，会将这些对象进行范围之中的第二次回收，如果这次回收还没有足够的内存，才会抛出内存溢出的异常。

- 弱引用：描述那些非必要对象，被弱引用关联的对象只能生存到下一次垃圾收集发生为止，当垃圾收集器开始工作，无论当前内存够不够，都会回收被弱引用关联的对象。
- 虚引用：唯一的目的就是能在这个对象被收集时接收到一个系统通知

## 判断对象死亡

宣告对象死亡，至少要经过两次标记，如果对象在进行可达性分析后没有发现与GC Root相连接的引用链，则它会被第一次标记，随后进行一次筛选，判断是否有必要执行finalize()方法。如果对象没有覆盖finalize()方法，或者finalize方法已经被虚拟机调用过，那么虚拟机将这两种情况视为“没有必要执行”。

finalize()方法是对象逃脱死亡命运的最后一次机会，如果对象想在finalize中活下来，只需要与引用链上的任意一个对象建立关联即可。这种自救方式只能进行一次，，如果面临下一次回收，finalize()方法不会被再次执行。

##### 垃圾收集算法

##### 分代收集理论

###### 分代假说

- 弱分代假说：绝大多对象都是朝生夕灭的
- 强分代假说：熬过越多次垃圾收集过程的对象越难以消亡。

垃圾收集器的一致设计原则：将java堆划分出不同的区域，根据对象熬过的垃圾收集的次数将它们分配到不同的区域之中存储。

困难：对象之间会存在跨代引用

- 跨代引用假说：跨代引用对于同代引用来说仅占极少数（新生代会跨越到老年代以消除跨代）

在新生代上建立一个全局的数据结构，将老年代划分为若干小块，标识出老年代的哪一块会出现跨代引用，发生Minor GC时，包含了跨代引用的小块内存里的对象才会被加入GC Root中进行扫描。

###### 标记—清除算法

首先，标记出需要回收的对象，在标记完成后，统一回收被标记的对象

缺点：

- 标记和清除两个过程的效率随着要被清除的对象的增多而降低
- 内存空间碎片化，空间碎片太多会导致以后在分配较大对象时无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。

空间碎片化的解决方案：分区空闲分配链表，硬盘存储大文件不需要物理连续的磁盘空间，实现在碎片化的硬盘上存储和访问就是通过硬盘分区表实现的）

###### 标记—复制算法

将可用内存按容量划分为大小相等的两块，每次只使用其中的一块，这一块的内存用完了，就将还存活着的对象复制到另外一块，再把已使用过的空间一次清理掉。

缺点：

- 如果对象大部分都是存活的，将会产生大量的内存空间复制的开销
- 可使用的内存空间减少了一半（新生代特点：98%对象熬不过第一轮收集，不需要采用1：1的比例划分新生代的内存空间）

优点：无空间碎片，实现简单

###### 标记—整理算法

针对老年代对象存亡的特点，让所有存活的对象都想内存空间的一端移动，然后直接清理掉边界以外的内存。是一种移动式的回收算法，这种对象移动的操作必须全程暂停用户应用程序才能进行。移动则内存回收时会更复杂，不移动则内存分配会更复杂。

#### 讲一讲类加载机制

类加载的过程是指将class文件加载到内存，并对数据进行检验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型。

类的生命周期：**加载--->验证--->准备--->解析--->初始化--->使用--->卸载**

###### 加载阶段

- 通过一个类的全限定名来获取类的二进制字节流
- 将字节流所代表的静态存储结构转化为方法区的运行时数据结构
- 在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。

###### 验证阶段

目的：确保Class文件的字节流中包含的信息符合规范要求。

- 文件格式验证
- 元数据验证
- 字节码验证
- 符号引用验证

###### 准备阶段

为类中定义的变量（静态变量，被static修饰的变量）分配内存并设置类变量初始值的阶段，被final修饰的static字段不会设置，因为final在编译的时候就分配了

###### 解析（Resolve）

解析阶段的目的，是将常量池内的符号引用转换为直接引用的过程（将常量池内的符号引用解析成为实际引用）。如果符号引用指向一个未被加载的类，或者未被加载类的字段或方法，那么解析将触发这个类的加载（但未必触发这个类的链接以及初始化。）

事实上，解析器操作往往会伴随着 JVM 在执行完初始化之后再执行。 符号引用就是一组符号来描述所引用的目标。符号引用的字面量形式明确定义在《Java 虚拟机规范》的Class文件格式中。直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。

###### 初始化

初始化就是执行类的构造器方法init()的过程

由javac编译器自动收集类中所有类变量的赋值动作和静态代码块中的语句合并而来。

该类如果有父类，jvm会保证父类的init先执行，然后再执行子类的init。

##### 类加载器

java虚拟机将类加载阶段的“通过一个类的限定名获取描述该类的二进制字节流”放到虚拟机的外部去进行，让应用程序自己去获取所需的类。实现这个的代码被称为类加载器。比较两个类是否相等，只有在这两个类是由同一个类加载器加载的前提下才有意义（类本身相同，且加载它的类加载器也相同）。

##### 双亲委派模型

在java虚拟机之中，只存在两种不同的类加载器，一种是启动类加载器(Bootstrap ClassLoader，基于C++实现),另外一种是其它所有的类加载器，，这些类由java实现，独立于虚拟机外部，继承java.lang.ClassLoader。

###### 三层类加载器

- 启动类加载器：加载<JAVA_HOME>\lib目录，或-Xbootclasspath参数所指定的路径中存放的可识别的类库加载到虚拟机的内存中。
- 扩展类加载器(Extension Class Loader)：负责加载<JAVA_HOME>\lib\ext目录中或被java.ext.dirs系统变量所指定的路径中所有的类库。在JDK9之后被模板化的扩展能力所取代。
- 应用程序加载器(Application Class Loader):负责加载用户类路径上所有的类库

###### 类加载器的双亲委派模型

![image-20210827192346537](https://cdn.jsdelivr.net/gh/nanxi1234/nanxi1234.github.io/image/2021/20210827192353.png)



双亲委派模型除了顶层的启动类加载器外，其余加载器都有自己的父类加载器，不过父子关系不是指的继承关系，而是使用组合关系复用父加载器的代码。

- 工作过程：如果一个类加载器收到了类加载请求，它会先将请求委派给父加载器进行加载，，当父加载器反馈无法完成加载时，子加载器才会尝试自己去完成加载。
- 好处：Java中的类随着它的类加载器一起具备了一种带有优先级的层次关系，能类在各种类加载器环境中**保证是同一个类。避免了类的重复加载，当父加载器已经加载过一个类时，子加载器就不会再加载。保证了安全性，防止自定义的带有破坏功能的类替换掉已有的类被加载。**

###### 双亲委派的实现

- 检查类是否已被加载过
- 若没加载则调用父加载器的loadClass方法进行加载
- 若父加载器为空则默认使用启动类加载器作为父加载器
- 若父类加载失败，抛出ClassNotFoundException异常后，再调用自己的findClass方法进行加载。

###### 破坏双亲委派机制

- 双亲委派出现之前
- JNDI\JDBC等需要加载SPI接口实现类的情况
- 实现热插拔热部署工具：为了让代码动态生效无需重启，实现方式：把模块连同类加载器一起换掉。
- tomcat等web容器的出现
- OSGI\Jigsaw等模块化技术的应用

###### JDK9后的类加载委派关系

扩展类加载器被平台类加载器替代，当平台及应用程序类加载器收到类加载请求，在委派给父加载器前，要先判断该类是否能够归属到某一个系统模块之中，如果可以，就要优先委派给负责那个模块的加载器完后加载。
