---
title: java虚拟机
tags:
 
---



# 内存区域与内存溢出异常

## 运行时数据区域

![演示文稿1](https://cdn.jsdelivr.net/gh/nanxi1234/nanxi1234.github.io/image/2021/20210620200635.jpg)

### 程序计数器

是一块较小的内存空间，它可以看作当前线程所执行的字节码的行号指示器，字节码解释器的工作时通过改变这个计数器的值来选取下一条所要执行的字节码指令。

由于Java的多线程是通过线程轮流切换，分配处理器执行时间的方式来实现的，为了线程切换之后能够恢复到正确的执行位置，每条线程都需要有自己的程序计数器，称这类内存区域为*线程私有内存*。

唯一一个没有OutOfMemoryError情况的区域

### java虚拟机栈

虚拟机栈也是线程私有的，生命周期与线程相同，虚拟机栈描述的是java方法执行的线程内存模型，每个方法执行时，虚拟机会同步创造一个栈帧用于存储局部变量表、操作数栈、动态连接、方法出口等信息，每一个方法从被调用到执行完毕的过程中，对应一个个栈帧在虚拟机中入栈出栈的过程。

局部变量表存放了编译期可知的各种Java虚拟机基本数据类型：boolean、char、byte、long、short、int、String、double

64位的double和long类型的数据会占用两个变量槽，其余的数据类型只用一个

异常情况：如果线程请求的栈深度大于虚拟机所允许的深度，将会抛出StackOverFlowError异常；如果虚拟机的内存可以动态拓展，当栈无法申请到足够的内存时会抛出OutOfMemoryError异常。

### 本地方法栈

JAVA方法是由JAVA编写的，编译成字节码，存储在class文件中

本地方法是由其它语言编写的，编译成和处理器相关的机器代码

和虚拟机栈所发挥的作用相似，区别在于虚拟机栈只为虚拟机所执行的java方法服务，而本地方法栈则是为虚拟机使用到的本地方法服务。

异常：和虚拟机栈一样

### java堆

java堆是被所有线程共享的一块内存区，是虚拟机管理的内存之中最大的一块，此区域唯一的目的是存放对象实例，“几乎所有的对象都在这里分配内存”(栈上分配、标量替换使它没有那么绝对)

java堆是垃圾收集器管理的内存区域，，将java堆细分的目的在于更好地回收内存，或更快地分配内存。

java堆可以处于物理上不连续的内存空间中，但是在逻辑上应该被视为连续的，java堆可被设计为固定大小的，也可以是扩展的，现在主流的java虚拟机都是按照可扩展来实现的，如果内存不够时会抛出OutOfMemoryError。

### 方法区

线程共享，用于存储被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据。

不需要连续空间，可扩展，可以选择不实现垃圾收集，这个区域的回收目标主要是针对常量池的回收和对类型的卸载，但是回收条件较为苛刻，因此回收效果不好。如果内存不够时会抛出OutOfMemoryError。

#### 运行时常量池

方法区的一部分，常量池表：用于存放编译期生成的各种字面量与符号引用，这部分内容在类加载后存放到方法区的运行时常量之中。不同提供商可按照自己的需求实现这个内存区域。

常量不一定只有在编译期才产生，运行期间也可以将新的常量放入池中。如果内存不够时会抛出OutOfMemoryError。

### 直接内存

不属于虚拟机运行时数据区，本机直接内存的分配不会受java堆大小的影响，但会受到本机内存大小及处理器寻址空间的限制。

## java虚拟机对象

### 对象的创建

![虚拟机中对象的创建流程](https://cdn.jsdelivr.net/gh/nanxi1234/nanxi1234.github.io/image/2021/20210622200300.jpg)

- 对象创建的线程安全问题

① 对分配内存空间的动作进行同步处理

②把内存分配的动作按照线程划分在不同空间进行，即每个线程在java堆中进行预先分配一小块内存，称为本地线程分配缓冲（Thread Local Allocation Buffer,TLAB）,哪个线程要分配内存先从缓冲区分配，只有本地缓冲区用完了，分配新的缓冲区时才需要同步锁定。

### 对象的内存布局

对象在堆内存中的存储布局可以划分为三大部分：*对象头*，*实例数据*、*对齐填充*。

- 对象头：主要包括两部分信息，一是用于存储自身的运行时数据，一是类型指针(即对象指向它的类型元数据的指针，java虚拟机通过这个指针来确定该对象是哪个类的实例)
- 实例数据：对象真正存储的有效信息，即我们在代码中所定义的各种类型的字段内容
- 对齐填充：任何对象的大小必须是8的倍数，对象头已被设计为8的倍数，如果对象实例数据部分没有对齐的话，就需要通过对齐填充来补全。

###  对象的访问定位

由于reference类型在《java虚拟机规范》中只是一个指向对象的引用，并没有定义这个引用通过什么方式定位、访问堆中对象的具体位置，因此对象访问的工作应由虚拟机实现。目前主流的访问方式主要有使用句柄和直接指针两种。

- 句柄访问：java堆中划分出一块内存作为句柄池，reference中存储的就是对象的句柄地址，句柄包括对象实例数据与类型数据各自具体的地址信息。
- 直接指针访问：reference中存放的就是对象地址，少一次间接访问的开销

优缺点分析：

使用句柄访问的最大好处就是reference中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据的指针，reference不需要被修改。

直接指针的好处是能节省一次指针定位的时间。

# 垃圾收集器与内存分配策略

