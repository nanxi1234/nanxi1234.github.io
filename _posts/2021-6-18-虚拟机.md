---
title: java虚拟机
tags:
 
---



# 内存区域与内存溢出异常

## 运行时数据区域

![演示文稿1](https://cdn.jsdelivr.net/gh/nanxi1234/nanxi1234.github.io/image/2021/20210620200635.jpg)

### 程序计数器

是一块较小的内存空间，它可以看作当前线程所执行的字节码的行号指示器，字节码解释器的工作时通过改变这个计数器的值来选取下一条所要执行的字节码指令。

由于Java的多线程是通过线程轮流切换，分配处理器执行时间的方式来实现的，为了线程切换之后能够恢复到正确的执行位置，每条线程都需要有自己的程序计数器，称这类内存区域为*线程私有内存*。

唯一一个没有OutOfMemoryError情况的区域

### java虚拟机栈

虚拟机栈也是线程私有的，生命周期与线程相同，虚拟机栈描述的是java方法执行的线程内存模型，每个方法执行时，虚拟机会同步创造一个栈帧用于存储局部变量表、操作数栈、动态连接、方法出口等信息，每一个方法从被调用到执行完毕的过程中，对应一个个栈帧在虚拟机中入栈出栈的过程。

局部变量表存放了编译期可知的各种Java虚拟机基本数据类型：boolean、char、byte、long、short、int、String、double

64位的double和long类型的数据会占用两个变量槽，其余的数据类型只用一个

异常情况：如果线程请求的栈深度大于虚拟机所允许的深度，将会抛出StackOverFlowError异常；如果虚拟机的内存可以动态拓展，当栈无法申请到足够的内存时会抛出OutOfMemoryError异常。

### 本地方法栈

JAVA方法是由JAVA编写的，编译成字节码，存储在class文件中

本地方法是由其它语言编写的，编译成和处理器相关的机器代码

和虚拟机栈所发挥的作用相似，区别在于虚拟机栈只为虚拟机所执行的java方法服务，而本地方法栈则是为虚拟机使用到的本地方法服务。

异常：和虚拟机栈一样

### java堆

java堆是被所有线程共享的一块内存区，是虚拟机管理的内存之中最大的一块，此区域唯一的目的是**存放对象实例**，“几乎所有的对象都在这里分配内存”(栈上分配、标量替换使它没有那么绝对)

java堆是垃圾收集器管理的内存区域，，将java堆细分的目的在于更好地回收内存，或更快地分配内存。

java堆可以处于物理上不连续的内存空间中，但是在逻辑上应该被视为连续的，java堆可被设计为固定大小的，也可以是扩展的，现在主流的java虚拟机都是按照可扩展来实现的，如果内存不够时会抛出OutOfMemoryError。

### 方法区

线程共享，用于存储被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据。

不需要连续空间，可扩展，可以选择不实现垃圾收集，这个区域的回收目标主要是针对常量池的回收和对类型的卸载，但是回收条件较为苛刻，因此回收效果不好。如果内存不够时会抛出OutOfMemoryError。

#### 运行时常量池

方法区的一部分，常量池表：用于存放编译期生成的各种字面量与符号引用，这部分内容在类加载后存放到方法区的运行时常量之中。不同提供商可按照自己的需求实现这个内存区域。

常量不一定只有在编译期才产生，运行期间也可以将新的常量放入池中。如果内存不够时会抛出OutOfMemoryError。

### 直接内存

不属于虚拟机运行时数据区，本机直接内存的分配不会受java堆大小的影响，但会受到本机内存大小及处理器寻址空间的限制。

## java虚拟机对象

### 对象的创建

![虚拟机中对象的创建流程](https://cdn.jsdelivr.net/gh/nanxi1234/nanxi1234.github.io/image/2021/20210622200300.jpg)

- 对象创建的线程安全问题

① 对分配内存空间的动作进行同步处理

②把内存分配的动作按照线程划分在不同空间进行，即每个线程在java堆中进行预先分配一小块内存，称为本地线程分配缓冲（Thread Local Allocation Buffer,TLAB）,哪个线程要分配内存先从缓冲区分配，只有本地缓冲区用完了，分配新的缓冲区时才需要同步锁定。

### 对象的内存布局

对象在堆内存中的存储布局可以划分为三大部分：*对象头*，*实例数据*、*对齐填充*。

- 对象头：主要包括两部分信息，一是用于存储自身的运行时数据，一是类型指针(即对象指向它的类型元数据的指针，java虚拟机通过这个指针来确定该对象是哪个类的实例)
- 实例数据：对象真正存储的有效信息，即我们在代码中所定义的各种类型的字段内容
- 对齐填充：任何对象的大小必须是8的倍数，对象头已被设计为8的倍数，如果对象实例数据部分没有对齐的话，就需要通过对齐填充来补全。

###  对象的访问定位

由于reference类型在《java虚拟机规范》中只是一个指向对象的引用，并没有定义这个引用通过什么方式定位、访问堆中对象的具体位置，因此对象访问的工作应由虚拟机实现。目前主流的访问方式主要有使用句柄和直接指针两种。

- 句柄访问：java堆中划分出一块内存作为句柄池，reference中存储的就是对象的句柄地址，句柄包括对象实例数据与类型数据各自具体的地址信息。
- 直接指针访问：reference中存放的就是对象地址，少一次间接访问的开销

优缺点分析：

使用句柄访问的最大好处就是reference中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据的指针，reference不需要被修改。

直接指针的好处是能节省一次指针定位的时间。

# 垃圾收集器与内存分配策略

## 概述

为什么需要垃圾回收？

当垃圾收集成为系统达到更高并发量的瓶颈，就必须对这些“自动化的技术“实施必要的监控和调节

垃圾收集需要完成的三件事：

- 哪些内存需要被回收？

java堆和方法区，，因为这两个区域有着显著的不确定性，只有在运行期间，才能知道程序要创建哪些对象， 创造多少对象，这部分的内存的分配和回收是动态的，垃圾收集器所关注的正是这部分内存该如何管理。

- 什么时候回收？

在堆中存放着java世界的几乎所有对象实例，垃圾收集器在对堆进行回收时，第一件事情就是确定哪些对象还”存活“，哪些已经”死去“（即不可能再被任何途径使用的对象）。

  几种判断算法：

①引用计数：在对象中添加引用计数器，每当一个地方引用它时，计数器值就加一，引用失效，计数器值减一。缺点：需要配合大量的额外处理才能保证正确的工作。如无法通过此方法解决对象之间循环引用的问题。

②可达性分析算法

通过一系列称为”GC Roots“的根对象作为起始节点集，从这些结点开始，根据引用关系向下搜索，搜索过程所走过的路径称为引用链，如果某个对象到GC Roots的根对象间没有任何引用链相连，则证明此对象不能再被使用。（局部回收时）某个区域的对象完全有可能被位于堆中的其它区域的对象所引用，这时就需要将这些关联区域的对象一并加入到GC Root集合中去，这样才能保证可达性分析的正确性。

- 如何回收？



## 引用

引用的类型：

强引用、软引用、弱引用、虚引用

- 强引用：Object obj = New Object，这种引用关系，无论任何情况，只要存在，垃圾收集器就永远不会回收掉引用的对象。
- 软引用：描述一些还有用但非必要的对象；被软引用关联的对象在系统将要发生内存溢出之前，会将这些对象进行范围之中的第二次回收，如果这次回收还没有足够的内存，才会抛出内存溢出的异常。

- 弱引用：描述那些非必要对象，被弱引用关联的对象只能生存到下一次垃圾收集发生为止，当垃圾收集器开始工作，无论当前内存够不够，都会回收被弱引用关联的对象。
- 虚引用：唯一的目的就是能在这个对象被收集时接收到一个系统通知

## 判断对象死亡

宣告对象死亡，至少要经过两次标记，如果对象在进行可达性分析后没有发现与GC Root相连接的引用链，则它会被第一次标记，随后进行一次筛选，判断是否有必要执行finalize()方法。如果对象没有覆盖finalize()方法，或者finalize方法已经被虚拟机调用过，那么虚拟机将这两种情况视为“没有必要执行”。

finalize()方法是对象逃脱死亡命运的最后一次机会，如果对象想在finalize中活下来，只需要与引用链上的任意一个对象建立关联即可。这种自救方式只能进行一次，，如果面临下一次回收，finalize()方法不会被再次执行。

## 垃圾收集算法

### 分代收集理论

#### 分代假说

- 弱分代假说：绝大多对象都是朝生夕灭的
- 强分代假说：熬过越多次垃圾收集过程的对象越难以消亡。

垃圾收集器的一致设计原则：将java堆划分出不同的区域，根据对象熬过的垃圾收集的次数将它们分配到不同的区域之中存储。

困难：对象之间会存在跨代引用

- 跨代引用假说：跨代引用对于同代引用来说仅占极少数（新生代会跨越到老年代以消除跨代）

在新生代上建立一个全局的数据结构，将老年代划分为若干小块，标识出老年代的哪一块会出现跨代引用，发生Minor GC时，包含了跨代引用的小块内存里的对象才会被加入GC Root中进行扫描。

#### 标记—清除算法

首先，标记出需要回收的对象，在标记完成后，统一回收被标记的对象

缺点：

- 标记和清除两个过程的效率随着要被清除的对象的增多而降低
- 内存空间碎片化，空间碎片太多会导致以后在分配较大对象时无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。

#### 标记—复制算法

将可用内存按容量划分为大小相等的两块，每次只使用其中的一块，这一块的内存用完了，就将还存活着的对象复制到另外一块，再把已使用过的空间一次清理掉。

缺点：

- 如果对象大部分都是存活的，将会产生大量的内存空间复制的开销
- 可使用的内存空间减少了一半（新生代特点：98%对象熬不过第一轮收集，不需要采用1：1的比例划分新生代的内存空间）

优点：无空间碎片，实现简单

#### 标记—整理算法

针对老年代对象存亡的特点，让所有存活的对象都想内存空间的一端移动，然后直接清理掉边界以外的内存。是一种移动式的回收算法，这种对象移动的操作必须全程暂停用户应用程序才能进行。移动则内存回收时会更复杂，不移动则内存分配会更复杂。

