---
title: nowcoder-project
tags:

---



##### 事务隔离

- 什么是事务

事务就是逻辑上的一组操作，要么全部执行，要么全都不执行

- 事务的特性（ACID）

1. 原子性： 事务是最小的执行单位，不可分割，事务的原子性确保动作要么全部完成，要么全失败回滚。
2. 一致性：执行事务前后，数据保持一致。
3. 隔离性：并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的。
4. 持久性：一个事务被提交之后，它对数据库中数据的改变是持久的，即使数据库发生故障也不会有影响。

###### 并发事务带来的问题

- 脏读：当A事务正在访问数据并对数据进行了修改，而这种修改还未提交到数据库中，这时B事务也访问了这个还未提交的数据，并且使用了这个数据，因为这个数据还未提交，如果A事务发生错误，进行**回滚**操作，那么B事务读到的就是脏数据。



- 丢失修改：一个事务读取数据时，另外一个事务也访问了该数据，在第一个事务修改了这个数据之后，第二个事务也修改了这个数据，这样第一个事务内的修改结果就被丢失。



- 不可重复读：指在**一个事务内**多次读取同一数据，在A事务还未结束时，B事务也访问该数据并进行修改，那么在第一个事务的两次读数据之间，前后读到的数据不一致，称为不可重复读（重复读可能会出错）



- 幻读：幻读与不可重复读类似，A事务在事务内多次查询数据，由于事务B对数据进行了增加，导致第一次查询与第二次查询的结果不一致



问题：不可重复读与幻读有什么区别？

（1） 不可重复读是读取了事务修改的数据，针对**update**操作

   解决方案：使用行级锁，锁定该行，事务A多次读取完成后才释放该锁，这个时候才允许其他事务更改刚才的数据。

（2）幻读是读取了其他事务新增的数据，针对**insert**和**delete**操作

解决：使用表级锁，锁定整张表，事务A多次读取数据总量之后才释放该锁，这个时候才允许其他事务更改刚才的数据。

###### 数据库的隔离级别

|                              | 脏读 | 不可重复读 | 幻读 |
| :--------------------------: | :--: | :--------: | :--: |
| Read uncommitted（读未提交） |  √   |     √      |  √   |
|   Read committed（读提交）   |  ×   |     √      |  √   |
|   Repeatable read(重复读)    |  ×   |     ×      |  √   |
|         Serializable         |  ×   |     ×      |  ×   |

- Read uncommitted（读未提交）

数据还未提交就开始读，最弱的隔离级别，这种情况下所有情况都会发生

- Read committed（读提交）

读提交的数据，这样可以避免脏读（不会因为回滚读到脏数据），但是无法避免不可重复读，大多数数据库的默认级别就是Read committed（Sql Server , Oracle）

- Repeatable read(重复读)

对于数据库中的某一个数据，一个事务范围内多次查询却返回了不同的数据值，这是由于在查询间隔中被另外一个事务修改并提交了。Repeatable read可以保证在多次查询这个事务进行时，其他事务无法修改数据。但是避免不了幻读。Mysql的默认隔离级别就是Repeatable read。

- Serializable序列化（串行化）

Serializable 是最高的事务隔离级别，同时代价也**花费最高，性能很低，一般很少使用**，在该级别下，事务顺序执行，不仅可以避免脏读、不可重复读，还避免了幻读。

###### 悲观锁 && 乐观锁

- 悲观锁

指对数据被外界修改持保守态度，因此在整个数据处理过程中，将数据处于锁定状态。如何实现？依靠数据库提供的锁机制，只有数据库底层提供的锁机制才能真正地保证数据访问的排他性，否则即使在本系统中实现了加锁机制，也无法保证外部系统不会修改数据。在悲观锁下，为保证事务的隔离性，需要一致性锁定读，读取数据时加锁（其它事务无法修改），修改数据时也加锁（其他事务无法读取）。

- 乐观锁

悲观锁大多情况下依靠数据库的锁机制实现，以保证操作的最大程度的独占性，但是缺点在于开销太大，影响数据库的性能。

乐观锁在一定程度上解决了这个问题。乐观锁基于**数据版本**记录机制实现。即为数据库表增加一个“version”字段来实现。读取出数据时，将此版本号一同读出，之后更新时，对此版本号加一。将提交的版本数据与数据库中记录的版本信息对比，如果数据版本号大于数据库中的版本号，则更新。否则认为是过期数据。

- 当前读：它读取的数据库记录，都是`当前最新`的`版本`，会对当前读取的数据进行`加锁`，防止其他事务修改数据。是`悲观锁`的一种操作。

  如下操作都是当前读：

  - select lock in share mode (共享锁)
  - select for update (排他锁)
  - update (排他锁)
  - insert (排他锁)
  - delete (排他锁)
  - 串行化事务隔离级别

- 快照读：快照读的实现是基于`多版本`并发控制，即MVCC，既然是多版本，那么快照读读到的数据不一定是当前最新的数据，有可能是之前`历史版本`的数据。

  如下操作是快照读：
  
  - 不加锁的select操作（注：事务级别不是串行化）
  
  

###### MVCC（多版本并发控制）

以乐观锁理论为基础，没有固定的规范，每个数据库都会有不同的实现机制

MySql中默认的事务隔离级别是可重复读，为了解决不可重复读的问题，innodb采用了MVCC来解决这一问题。

MVCC在每条数据后面加了隐藏的两列（创建版本号和删除版本号），每个事务开始的时候都会有一个递增的版本号。

增：创建版本号+1

改：采用delete+add的方式实现，先将当前版本+1=删除版本号，再将当前版本号+1=新增版本号

|  id  | name | age  | create_version | delete_version |
| :--: | :--: | :--: | :------------: | :------------: |
|  1   | alex |  18  |       1        |       2        |

|  id  | name | age  | create_version | delete_version |
| :--: | :--: | :--: | :------------: | :------------: |
|  1   | alex |  18  |       1        |       2        |
|  1   | alex |  18  |       2        |                |

删：直接将数据的删除版本号更新为当前事务的版本号

查：查询操作为避免查询到旧数据或已被其他事务更改过的数据，需要满足：

- 查询时当前事务的版本号需要大于等于创建版本号
- 查询时当前事务的版本号需要小于删除的版本号



- 1.MVCC手段只适用于MySql隔离级别中的读已提交（Read committed）和可重复读（Repeatable Read）.  
- 2.Read uncommitted由于存在脏读，即能读到未提交事务的数据行，所以不适用MVCC.  原因是**MVCC的创建版本和删除版本只要在事务提交后才会产生**。 
-  3.串行化由于是会对所涉及到的**表加锁，并非行锁**，自然也就不存在行的版本控制问题。

综上，MVCC主要用于事务性的，有行锁控制的数据库模型。

###### 说明

- 快照读

读操作只读取该事务开始前的数据库快照

并发读-写时：可以做到读操作不阻塞写操作，同时写操作不会阻塞读操作（其实就是每个事务都有一个自己的数据库版本，这样就不会冲突了）

解决脏读、幻读、不可重复读等问题，但无法解决写---写更新丢失

因此需要组合：

- MVCC + 乐观锁：MVCC解决读写冲突，乐观锁解决写写冲突
- MVCC + 悲观锁：MVCC解决读写冲突，悲观锁解决写写冲突



##### MVCC实现原理

三部分： 版本链，undo log，Read View来实现的

- 版本链：数据库的每行数据，有几个隐藏字段分别是：`db_trx_id`、`db_roll_pointer`、`db_row_id`。

`db_trx_id`是当前操作该记录的事务ID，`db_roll_pointer`是一个回滚指针，用于配合undo log，指向旧版本，`db_trx_id`是数据库默认为该行数据生成的唯一隐式主键。

每次对数据库记录进行改动，都会记录一条`undo日志`，每条undo日志也都有一个`roll_pointer`属性（INSERT操作对应的undo日志没有该属性，因为该记录并没有更早的版本）对该记录每次更新后，都会将旧值放到一条undo日志中，就算是该记录的一个旧版本，随着更新次数的增多，所有的版本都会被`roll_pointer`属性连接成一个`链表`，我们把这个链表称之为`版本链`，版本链的头节点就是当前记录最新的值。另外，每个版本中还包含生成该版本时对应的事务id。

- undolog日志

Undo log 主要用于`记录`数据被`修改之前`的日志，在表信息修改之前先会把数据拷贝到`undo log`里。

当`事务`进行`回滚时`可以通过undo log 里的日志进行`数据还原`。

- Undo log 的用途

（1）保证`事务`进行`rollback`时的`原子性和一致性`，当事务进行`回滚`的时候可以用undo log的数据进行`恢复`。

（2）用于MVCC`快照读`的数据，在MVCC多版本控制中，通过读取`undo log`的`历史版本数据`可以实现`不同事务版本号`都拥有自己`独立的快照数据版本`。

- undo log主要分为两种：

（1）insert undo log

代表事务在insert新记录时产生的undo log , 只在事务回滚时需要，并且在事务提交后可以被立即丢弃

（2）update undo log（主要）

事务在进行update或delete时产生的undo log ; 不仅在事务回滚时需要，在快照读时也需要；

所以不能随便删除，只有在快速读或事务回滚不涉及该日志时，对应的日志才会被purge线程统一清除

- Read View

事务进行`快照读`操作的时候生产的`读视图`(Read View)，在该事务执行的快照读的那一刻，会生成数据库系统当前的一个`快照`。

记录并维护系统当前`活跃事务的ID`(没有commit，当每个事务开启时，都会被分配一个ID, 这个ID是递增的，所以越新的事务，ID值越大)，是系统中当前不应该被`本事务`看到的`其他事务id列表`。

Read View主要是用来做`可见性`判断的, 即当我们`某个事务`执行`快照读`的时候，对该记录创建一个Read View读视图，把它比作条件用来判断`当前事务`能够看到`哪个版本`的数据，既可能是当前`最新`的数据，也有可能是该行记录的undo log里面的`某个版本`的数据。

- Read View几个属性

（1）`trx_ids`: 当前系统活跃(`未提交`)事务版本号集合。

（2）`low_limit_id`: 创建当前read view 时“当前系统`最大事务版本号`+1”。

（3）`up_limit_id`: 创建当前read view 时“系统正处于活跃事务`最小版本号`”

（4）`creator_trx_id`: 创建当前read view的事务版本号；

- `db_trx_id` < `up_limit_id` || `db_trx_id` == `creator_trx_id`（显示）

如果数据事务ID小于read view中的`最小活跃事务ID`，则可以肯定该数据是在`当前事务启之前`就已经`存在`了的,所以可以`显示`。

或者数据的`事务ID`等于`creator_trx_id` ，那么说明这个数据就是当前事务`自己生成的`，自己生成的数据自己当然能看见，所以这种情况下此数据也是可以`显示`的。

- `db_trx_id` >= `low_limit_id`（不显示）

如果数据事务ID大于read view 中的当前系统的`最大事务ID`，则说明该数据是在当前read view 创建`之后才产生`的，所以数据`不显示`。如果小于则进入下一个判断

- `db_trx_id`是否在`活跃事务`（trx_ids）中

`不存在`：则说明read view产生的时候事务`已经commit`了，这种情况数据则可以`显示`。

`已存在`：则代表我Read View生成时刻，你这个事务还在活跃，还没有Commit，你修改的数据，我当前事务也是看不见的

上面所讲的`Read View`用于支持`RC`（Read Committed，读提交）和`RR`（Repeatable Read，可重复读）`隔离级别`的`实现`。


###### RR、RC生成时机

- `RC`隔离级别下，是每个`快照读`都会`生成并获取最新`的`Read View`；
- 而在`RR`隔离级别下，则是`同一个事务中`的`第一个快照读`才会创建`Read View`, `之后的`快照读获取的都是`同一个Read View`，之后的查询就`不会重复生成`了，所以一个事务的查询结果每次`都是一样的`。

###### 解决幻读



###### RC、RR级别下的InnoDB快照读区别

- 在RR级别下的某个事务的对某条记录的第一次快照读会创建一个快照及Read View， 将当前系统活跃的其他事务记录起来，此后在调用快照读的时候，还是使用的是同一个Read View，所以只要当前事务在其他事务提交更新之前使用过快照读，那么之后的快照读使用的都是同一个Read View，所以对之后的修改不可见；
- 即RR级别下，快照读生成Read View时，Read View会记录此时所有其他活动事务的快照，这些事务的修改对于当前事务都是不可见的。而早于Read View创建的事务所做的修改均是可见
- 而在RC级别下的，事务中，每次快照读都会新生成一个快照和Read View, 这就是我们在RC级别下的事务中可以看到别的事务提交的更新的原因

##### 结论

MVCC指的就是在使用`READ COMMITTD`、`REPEATABLE READ`这两种隔离级别的事务在执行普通的`SEELCT`操作时访问记录的`版本链`的过程，这样子可以使不同事务的`读-写`、`写-读`操作`并发执行`，从而`提升系统性能`



##### 数据库comment表的内容

id:主键

user_id:用户id，评论是谁发布的

entity_type：评论目标的类别，如帖子、评论、用户等

entity_id：这个类型的目标具体是哪个目标

target_id：针对指向的人的id

content：评论内容

status：0正常；1禁用

###### Nginx进程模型

- master进程：主进程，接受外界的信号，分发给worker，如果worker发生异常，会重新启动新的worker

- worker进程：工作进程，执行master的业务。

<img src="https://cdn.jsdelivr.net/gh/nanxi1234/nanxi1234.github.io/image/2021/20210815163856.png" alt="image-20210815163849701" style="zoom:80%;" />

###### woker抢占机制

![image-20210815164301439](https://cdn.jsdelivr.net/gh/nanxi1234/nanxi1234.github.io/image/2021/20210815164301.png)

与传统服务器事件处理相比：

![image-20210815164404546](https://cdn.jsdelivr.net/gh/nanxi1234/nanxi1234.github.io/image/2021/20210815164404.png)

为什么nginx的性能这么高？抢占机制以及epoll模型的异步非阻塞的通信模式（高效），多路复用器。

###### nginx.conf配置结构

![image-20210815165612403](https://cdn.jsdelivr.net/gh/nanxi1234/nanxi1234.github.io/image/2021/20210815165612.png)

