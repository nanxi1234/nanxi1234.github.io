---
title: mysql
tags:

---

![img](https://cdn.jsdelivr.net/gh/nanxi1234/nanxi1234.github.io/image/2021/20210915104010.webp)

##### 事务隔离

- 什么是事务

事务就是逻辑上的一组操作，要么全部执行，要么全都不执行

- 事务的特性（ACID）

1. 原子性： 事务是最小的执行单位，不可分割，事务的原子性确保动作要么全部完成，要么全失败回滚。
2. 一致性：执行事务前后，数据保持一致。
3. 隔离性：一个事务所作的修改在最终提交之前，对其他事务是不可见的。
4. 持久性：一个事务被提交之后，它对数据库中数据的改变是持久的，即使数据库发生故障也不会有影响。

###### 并发事务带来的问题

- 脏读：当A事务正在访问数据并对数据进行了修改，而这种修改还未提交到数据库中，这时B事务也访问了这个还未提交的数据，并且使用了这个数据，因为这个数据还未提交，如果A事务发生错误，进行**回滚**操作，那么B事务读到的就是脏数据。

（A读到B的数据，这时B发生错误回滚，那么A读到的数据就是脏数据）

- 丢失修改：一个事务读取数据时，另外一个事务也访问了该数据，在第一个事务修改了这个数据之后，第二个事务也修改了这个数据，这样第一个事务内的修改结果就被丢失。

（A修改数据后，B也修改数据，导致A修改的数据丢失）

- 不可重复读：指在**一个事务内**多次读取同一数据，在A事务还未结束时，B事务也访问该数据并进行修改，那么在第一个事务的两次读数据之间，前后读到的数据不一致，称为不可重复读（重复读可能会出错）

（A读了两次两次结果竟然不一样，因为B在这之间修改了数据）

- 幻读：幻读与不可重复读类似，A事务在事务内多次查询数据，由于事务B对数据进行了增加，导致第一次查询与第二次查询的结果不一致



问题：不可重复读与幻读有什么区别？

（1） 不可重复读是读取了事务修改的数据，针对**update**操作

   解决方案：使用行级锁，锁定该行，事务A多次读取完成后才释放该锁，这个时候才允许其他事务更改刚才的数据。

（2）幻读是读取了其他事务新增的数据，针对**insert**和**delete**操作

解决：使用表级锁，锁定整张表，事务A多次读取数据总量之后才释放该锁，这个时候才允许其他事务更改刚才的数据。

###### 读写锁

为什么要把读写锁设计成读锁共享，写锁排他？

读不会修改数据，所以多个用户并发读并不会有问题，设计成共享锁能够提高性能。而写会修改数据，这保证了在同一时刻只有一个用户能执行写入，并防止其他用户读取正在写入的同一资源。

###### 更新丢失

第一类更新丢失：A事务回滚导致B事务已提交的数据被覆盖。

第二类更新丢失：A事务的更新把已提交的事务B的更新数据覆盖。

###### 锁的粒度

尽量只锁定需要修改的部分数据，而不是所有的资源。

锁策略就是在锁的开销和安全性之间寻找平衡。

###### 数据库的隔离级别

|                              | 脏读 | 不可重复读 | 幻读 |
| :--------------------------: | :--: | :--------: | :--: |
| Read uncommitted（读未提交） |  √   |     √      |  √   |
|   Read committed（读提交）   |  ×   |     √      |  √   |
|   Repeatable read(重复读)    |  ×   |     ×      |  √   |
|         Serializable         |  ×   |     ×      |  ×   |

- Read uncommitted（读未提交）

数据还未提交就开始读，最弱的隔离级别，这种情况下所有情况都会发生

- Read committed（读提交）

读提交的数据，这样可以避免脏读（不会因为回滚读到脏数据），但是无法避免不可重复读，大多数数据库的默认级别就是Read committed（Sql Server , Oracle）

- Repeatable read(重复读)

对于数据库中的某一个数据，一个事务范围内多次查询却返回了不同的数据值，这是由于在查询间隔中被另外一个事务修改并提交了。Repeatable read可以保证在多次查询这个事务进行时，其他事务无法修改数据。但是避免不了幻读。Mysql的默认隔离级别就是Repeatable read。

- Serializable序列化（串行化）

Serializable 是最高的事务隔离级别，同时代价也**花费最高，性能很低，一般很少使用**，在该级别下，事务顺序执行，不仅可以避免脏读、不可重复读，还避免了幻读。

###### 事务的死锁及解决方案

死锁是指两个或者多个事务在同一资源上相互占用，并请求锁定对方占用的资源，从而导致的恶性循环现象。当多个事务以不同的顺序锁定资源时，就可能会产生死锁。多个事务同时锁定同一个资源时，也会产生死锁。

解决方法：InnoDB：将持有的最少行级排它锁的事务进行回滚。

###### 悲观锁 && 乐观锁

- 悲观锁

指对数据被外界修改持保守态度，因此在整个数据处理过程中，将数据处于锁定状态。如何实现？依靠数据库提供的锁机制，只有数据库底层提供的锁机制才能真正地保证数据访问的排他性，否则即使在本系统中实现了加锁机制，也无法保证外部系统不会修改数据。在悲观锁下，为保证事务的隔离性，需要一致性锁定读，读取数据时加锁（其它事务无法修改），修改数据时也加锁（其他事务无法读取）。

- 乐观锁

悲观锁大多情况下依靠数据库的锁机制实现，以保证操作的最大程度的独占性，但是缺点在于开销太大，影响数据库的性能。

乐观锁在一定程度上解决了这个问题。乐观锁基于**数据版本**记录机制实现。即为数据库表增加一个“version”字段来实现。读取出数据时，将此版本号一同读出，之后更新时，对此版本号加一。将提交的版本数据与数据库中记录的版本信息对比，如果数据版本号大于数据库中的版本号，则更新。否则认为是过期数据。

- 当前读：它读取的数据库记录，都是`当前最新`的`版本`，会对当前读取的数据进行`加锁`，防止其他事务修改数据。是`悲观锁`的一种操作。

  如下操作都是当前读：

  - select lock in share mode (共享锁)
  - select for update (排他锁)
  - update (排他锁)
  - insert (排他锁)
  - delete (排他锁)
  - 串行化事务隔离级别

- 快照读：快照读的实现是基于`多版本`并发控制，即MVCC，既然是多版本，那么快照读读到的数据不一定是当前最新的数据，有可能是之前`历史版本`的数据。

  如下操作是快照读：
  
  - 不加锁的select操作（注：事务级别不是串行化）
  
  

###### MVCC（多版本并发控制）

以乐观锁理论为基础，没有固定的规范，每个数据库都会有不同的实现机制

MySql中默认的事务隔离级别是可重复读，为了解决不可重复读的问题，innodb采用了MVCC来解决这一问题。

MVCC在每条数据后面加了隐藏的两列（创建版本号和删除版本号），每个事务开始的时候都会有一个递增的版本号。

增：创建版本号+1

改：采用delete+add的方式实现，先将当前版本+1=删除版本号，再将当前版本号+1=新增版本号

|  id  | name | age  | create_version | delete_version |
| :--: | :--: | :--: | :------------: | :------------: |
|  1   | alex |  18  |       1        |       2        |

|  id  | name | age  | create_version | delete_version |
| :--: | :--: | :--: | :------------: | :------------: |
|  1   | alex |  18  |       1        |       2        |
|  1   | alex |  18  |       2        |                |

删：直接将数据的删除版本号更新为当前事务的版本号

查：查询操作为避免查询到旧数据或已被其他事务更改过的数据，需要满足：

- 查询时当前事务的版本号需要大于等于创建版本号
- 查询时当前事务的版本号需要小于删除的版本号

- 1.MVCC手段只适用于MySql隔离级别中的读已提交（Read committed）和可重复读（Repeatable Read）.  
- 2.Read uncommitted由于存在脏读，即能读到未提交事务的数据行，所以不适用MVCC.  原因是**MVCC的创建版本和删除版本只要在事务提交后才会产生**。 
-  3.串行化由于是会对所涉及到的**表加锁，并非行锁**，自然也就不存在行的版本控制问题。

综上，MVCC主要用于事务性的，有行锁控制的数据库模型。

###### 说明

- 快照读

读操作只读取该事务开始前的数据库快照

- 当前读

读取最新版本，并对读取的记录加锁，阻塞其他事务，避免出现安全问题

并发读-写时：快照可以做到读操作不阻塞写操作，同时写操作不会阻塞读操作（其实就是每个事务都有一个自己的数据库版本，这样就不会冲突了）

解决脏读、幻读、不可重复读等问题，但无法解决写---写更新丢失

因此需要组合：

- MVCC + 乐观锁：MVCC解决读写冲突，乐观锁解决写写冲突
- MVCC + 悲观锁：MVCC解决读写冲突，悲观锁解决写写冲突

###### 事务日志

使用事务日志，存储引擎在修改表的数据时只需要修改其内存拷贝，再把修改行为记录到持久在硬盘上的事务日志中，不用每次都将修改的数据本身持久到磁盘。事务日志采用追加的方式，因此写日志的操作是磁盘上一小块区域的顺序IO，不像随机IO需要在磁盘上多个地方移动磁头，所以采用事务日志的方式比较快，事务日志持久以后，内存中被修改的数据在后台可以慢慢刷回磁盘，这称之为预写式日志，修改数据需要写两次磁盘。

为什么要这样设计？

好处是如果将数据的修改已经记录到事务日志并持久化，但数据本身还没有写回磁盘，此时系统崩溃，存储引擎在重启时能够自动恢复这部分修改的数据。

##### MVCC实现原理

MVCC只在REPEATABLE READ和READ COMMITED两个隔离级别下工作，因为READ UNCOMMITED总是读取最新的数据行，而不是符合当前事务版本的数据行，而SERIALIZABLE则会对所有读取的行都加锁。

三部分： 版本链，undo log，Read View来实现的

- Mysql事务是如何实现的？

原子性：undo log，每条数据变更都伴随着一条undo log日志的生成，当系统发生错误或执行回滚根据undo log做逆向操作。

持久性：通过redo log实现，redo log记录；了数据的修改日志。数据持久化到磁盘，先是存储到缓冲池中，然后缓冲池中的数据定期同步到磁盘中，如果系统宕机，可能会丢死数据，系统重启后会读取redo log恢复数据。

隔离性：通过MVCC+间隙锁（next-key）机制实现了隔离性

一致性：以上的三个特性保障了事务的一致性



- 版本链：数据库的每行数据，有几个隐藏字段分别是：`db_trx_id`、`db_roll_pointer`、`db_row_id`。

`db_trx_id`是当前操作该记录的事务ID，`db_roll_pointer`是一个回滚指针，用于配合undo log，指向旧版本，`db_trx_id`是数据库默认为该行数据生成的唯一隐式主键。

每次对数据库记录进行改动，都会记录一条`undo日志`，每条undo日志也都有一个`roll_pointer`属性（INSERT操作对应的undo日志没有该属性，因为该记录并没有更早的版本）对该记录每次更新后，都会将旧值放到一条undo日志中，就算是该记录的一个旧版本，随着更新次数的增多，所有的版本都会被`roll_pointer`属性连接成一个`链表`，我们把这个链表称之为`版本链`，版本链的头节点就是当前记录最新的值。另外，每个版本中还包含生成该版本时对应的事务id。

- undolog日志

Undo log 主要用于`记录`数据被`修改之前`的日志，在表信息修改之前先会把数据拷贝到`undo log`里。

当`事务`进行`回滚时`可以通过undo log 里的日志进行`数据还原`。

![img](https://cdn.jsdelivr.net/gh/nanxi1234/nanxi1234.github.io/image/2021/20210920113925.png)

- Undo log 的用途

（1）保证`事务`进行`rollback`时的`原子性和一致性`，当事务进行`回滚`的时候可以用undo log的数据进行`恢复`。

（2）用于MVCC`快照读`的数据，在MVCC多版本控制中，通过读取`undo log`的`历史版本数据`可以实现`不同事务版本号`都拥有自己`独立的快照数据版本`。

- undo log主要分为两种：

（1）insert undo log

代表事务在insert新记录时产生的undo log , 只在事务回滚时需要，并且在事务提交后可以被立即丢弃

（2）update undo log（主要）

事务在进行update或delete时产生的undo log ; 不仅在事务回滚时需要，在快照读时也需要；

所以不能随便删除，只有在快速读或事务回滚不涉及该日志时，对应的日志才会被purge线程统一清除

- Read View

事务进行`快照读`操作的时候生产的`读视图`(Read View)，在该事务执行的快照读的那一刻，会生成数据库系统当前的一个`快照`。

记录并维护系统当前`活跃事务的ID`(没有commit，当每个事务开启时，都会被分配一个ID, 这个ID是递增的，所以越新的事务，ID值越大)，是系统中当前不应该被`本事务`看到的`其他事务id列表`。

Read View主要是用来做`可见性`判断的, 即当我们`某个事务`执行`快照读`的时候，对该记录创建一个Read View读视图，把它比作条件用来判断`当前事务`能够看到`哪个版本`的数据，既可能是当前`最新`的数据，也有可能是该行记录的undo log里面的`某个版本`的数据。

- Read View几个属性

（1）`trx_ids`: 当前系统活跃(`未提交`)事务版本号集合。

（2）`low_limit_id`: 创建当前read view 时“当前系统`最大事务版本号`+1”。

（3）`up_limit_id`: 创建当前read view 时“系统正处于活跃事务`最小版本号`”

（4）`creator_trx_id`: 创建当前read view的事务版本号；

- `db_trx_id` < `up_limit_id` || `db_trx_id` == `creator_trx_id`（显示）

如果数据事务ID小于read view中的`最小活跃事务ID`，则可以肯定该数据是在`当前事务启之前`就已经`存在`了的,所以可以`显示`。

或者数据的`事务ID`等于`creator_trx_id` ，那么说明这个数据就是当前事务`自己生成的`，自己生成的数据自己当然能看见，所以这种情况下此数据也是可以`显示`的。

- `db_trx_id` >= `low_limit_id`（不显示）

如果数据事务ID大于read view 中的当前系统的`最大事务ID`，则说明该数据是在当前read view 创建`之后才产生`的，所以数据`不显示`。如果小于则进入下一个判断

- `db_trx_id`是否在`活跃事务`（trx_ids）中

`不存在`：则说明read view产生的时候事务`已经commit`了，这种情况数据则可以`显示`。

`已存在`：则代表我Read View生成时刻，你这个事务还在活跃，还没有Commit，你修改的数据，我当前事务也是看不见的

上面所讲的`Read View`用于支持`RC`（Read Committed，读提交）和`RR`（Repeatable Read，可重复读）`隔离级别`的`实现`。


###### RR、RC生成时机

- `RC`隔离级别下，是每个`快照读`都会`生成并获取最新`的`Read View`；
- 而在`RR`隔离级别下，则是`同一个事务中`的`第一个快照读`才会创建`Read View`, `之后的`快照读获取的都是`同一个Read View`，之后的查询就`不会重复生成`了，所以一个事务的查询结果每次`都是一样的`。

###### Bin log和Redo log的区别，分别是干啥用的？

- bin log

  是二进制文件，记录了对数据库执行**更改**的所有操作，不包含select、show，因为这两个操作没有对数据本身修改。若是操作了数据，但是数据没有发生变化，也不会记录到bin log，通常用来做数据恢复，数据备份。

- redo log

  redo log用于实现事务的特性之一：持久性，即只要事务提交成功成功了，那么对数据库所作的修改就被永久地保存了下来，不可能因为任何原因再回到原来的状态。

  它是如何实现的？

  最简单的做法是在每次提交事务的时候。将事务涉及修改的数据页全部刷新到磁盘中，但是这样做会有严重的性能问题，因为Innodb是以页为单位进行磁盘交互的，而一个事务很可能只修改一个数据页里面的几个字段，这个时候将完整的数据页刷到磁盘的话，会比较浪费资源。

  一个事务可能一次修改多个数据页，并且这些页在物理上并不连续，使用随机IO读写性能太差。

  mysql为了提升性能不会把每次的修改都同步到磁盘，而是会先存到Buffer Pool（缓存池中），然后再使用后台线程去做缓存池和磁盘之间的同步。
  
  page的作用？page只是作为一个Record的保存容器，它存在的目的是便于对磁盘空间进行批量管理。

###### 解决幻读

- 在快照读情况下，通过MVCC来避免幻读。

- 在当前读的情况下，通过Next-key Lock(行锁+gap锁)策略防止幻读的出现，间隙锁使InnoDB不仅仅锁定查询涉及的行，还会对索引中的间隙进行锁定，防止幻影行的插入。

###### RC、RR级别下的InnoDB快照读区别

select：快照读

update\insert\delete：当前读

- 在RR级别下的某个事务的对某条记录的第一次快照读会创建一个快照及Read View， 将当前系统活跃的其他事务记录起来，此后在调用快照读的时候，还是使用的是同一个Read View，所以只要当前事务在其他事务提交更新之前使用过快照读，那么之后的快照读使用的都是同一个Read View，所以对之后的修改不可见；
- 即RR级别下，快照读生成Read View时，Read View会记录此时所有其他活动事务的快照，这些事务的修改对于当前事务都是不可见的。而早于Read View创建的事务所做的修改均是可见
- 而在RC级别下的，事务中，每次快照读都会新生成一个快照和Read View, 这就是我们在RC级别下的事务中可以看到别的事务提交的更新的原因

##### 结论

MVCC指的就是在使用`READ COMMITTD`、`REPEATABLE READ`这两种隔离级别的事务在执行普通的`SEELCT`操作时访问记录的`版本链`的过程，这样子可以使不同事务的`读-写`、`写-读`操作`并发执行`，从而`提升系统性能`

##### Mysql索引（典中典）

索引是存储引擎用于快速找到记录的一种数据结构，虽然索引能提高查询速度，但是会降低更新表的速度，在对表进行增删改时，Mysql不仅要保存数据，还要保存一下索引文件，建立索引会占用磁盘空间的索引文件

B-Tree之所以加快访问数据的访问，因为存储引擎不再需要进行全表扫描来获取需要的数据，取而代之的是从索引的根节点开始进行搜索，存储引擎根据这些指针向下层查找，通过比较节点页的值和要查找的值可以找到合适的指针进入下层子节点。

索引的优点：

- 索引大大减少了服务器需要扫描的数据量
- 索引帮助服务器避免排序和临时表
- 索引将随机IO变成顺序IO
- B+树的实现，叶子节点是顺序链表的形式，且一次IO会将一个磁盘的数据都读入，因此能够有效减少顺序遍历时的随机IO，由于有序，不会在内存中形成临时表

面经:

数据库索引为什么要用树结构存储？

树的查询效率高，而且可以保持有序

为什么索引不用二叉树来实现？

从算法上来讲两者确实都是logn的时间复杂度，但是我们还要考虑磁盘IO。数据库的索引是存储在磁盘上的，当数据量比较大的时候，索引的大小会很大。当进行索引查询时，将逐一加载每一个磁盘页，这里的磁盘页对应索引树的节点，如果使用二叉树进行查询，IO的次数取决于二叉树的高度，因此我们要想办法降低树的高度，以实现较少的IO次数。

B树：

一种多路平衡查找树，它的每一个节点最多包含k个孩子，k被称为B树的阶，k的大小取决于磁盘页的大小。

B+树：

B+树与B树的区别？

- B+树非叶子节点只存储关键字和指向子节点的指针，而B树还存储了卫星数据，在同样大小的情况下，B+树可以存储更多的节点元素。这就意味着，数据量相同的情况下，B+树的结构比B-树更加“矮胖”，因此查询时的IO次数也更少。（InnoDB中一页（默认16k）可以存放上千个单元即指针，如果树的高度为3，那么叶子节点即可存放千万条数据。所以在InnoDB中B+树高度一般为1-3层，它就能满足千万级的数据存储。在查找数据时一次页的查找代表一次IO，所以通过主键索引查询通常只需要1-3次IO操作即可查找到数据。）
- B+树的查询必须最终找到叶子节点，而B树只要找到匹配元素即可，所以B树的查找性能并不稳定，而B+树的每一次的查找都是稳定的。
- 范围查询时，B树要依靠中序遍历，而B+树的范围查询只需要在链表上做遍历即可。

###### 哈希索引

哈希索引是基于哈希表实现，只有精准匹配所有列的查询才有效，对于每一行数据，存储引擎都会对所有的索引队列计算一个哈希码，哈希码是一个较小的值，并且不同键值的行计算出来的哈希码也不一样，哈希索引将所有的哈希码存储在索引中，同时在哈希表中保存指向每个数据行的指针。

在mysql中，只有memory引擎显示支持哈希索引，也是memory引擎表的默认索引类型。

因为索引自身只需要存储对应的哈希值，所以索引的结构十分紧凑，哈希索引的查找速度很快，但是它也有自己的缺点：

- 哈希索引只包含哈希值和行指针，而不存储字段值，所以不能使用索引中的值来避免读取行，但是因为在内存中读取的速度很快，所以对性能的影响不大。
- 哈希索引数据并不是按照索引值顺序存储的，所以无法用于排序。
- 哈希索引不支持部分索引列匹配查找，因为哈希索引是使用索引列的全部内容来计算哈希值的。
- 哈希索引只支持等值比较查询，也不支持范围查询
- 访问哈希索引的速度很快，除非有很多哈希冲突，当出现哈希冲突时，要遍历链表中的行指针，逐步比较，直到找出所有符合条件的行，并且索引维护操作的代价也会很高

###### 聚簇索引和非聚簇索引

- 聚簇索引：又叫主键索引，每个表只有一个主键索引，叶子节点保存主键的值和数据。
- 非聚簇索引：又叫辅助索引，叶子节点保存索引字段的值和主键的值

聚集数据的优点：

- 可以把相关的数据保存在一起
- 数据访问更快
- 使用覆盖索引扫描的查询可以直接使用页节点中的主键值

面试题：

innodb辅助索引为什么存主键id，回表不是浪费时间吗？

- innodb二级索引的叶子节点存储的是主键值而不是*行指针*，并以此作为指向行的指针，这样的策略减少了当出现行移动或者数据页分裂（当行的主键值要求必须将这一行插入到某个已满的页中时，存储引擎会将该页分裂成两个页面来容纳该行，页分裂会导致表占用更多的磁盘空间）时二级索引的维护工作。使用主键索引值当作指针会让二级索引占用更多的空间，但是好处是Innodb在移动行时无需更新二级索引中的这个指针。
- 节省空间：因为innodb数据本身就已经在主键索引的B+树上了，利用回表查询可以节省再存一份数据的空间
- Innodb可以通过覆盖查询来避免对主键索引的二次查询

###### 前缀索引和覆盖索引

- 前缀索引：对于列的值较常，比如BLOB、TEXT、VARCHAR，就必须建立前缀索引，即将值的前一部分为索引。这样既可节约时间，又可以提高查询效率。
- 覆盖索引：select的数据列从索引中就能获得，不必再从数据库中获取。不是所有的索引都能成为覆盖索引，覆盖索引必须要存储索引列的值，因此只能用B-Tree索引作为覆盖索引

###### 最左前缀匹配

即最左优先，在检索数据时从联合索引的最左边开始匹配

- 为什么要用联合索引？

  减少开销，建一个联合索引，实际上相当于建立了（col1）、（col1,col2）、(col1,col2,col3)

  每多一个索引，都会增加写操作的开销和磁盘空间的开销，对于大量数据的表，使用联合索引会大大减少开销。

  效率高：两个单列查询返回行较多，同时查返回行较少，联合查询更高效

  避免回表：如在user的id列建有索引，select id from user这个不用回表，直接从索引中读取id的值，而select id,name from user中，不能返回除id列其他的值，所以必须要回表。

  最左匹配的原理深度解析

  假设对（a,b）字段建立索引，有

  <img src="https://cdn.jsdelivr.net/gh/nanxi1234/nanxi1234.github.io/image/2021/20210925170329.png" alt="39m1tvjfht" style="zoom:80%;" />

  先按照a来排序，在a相等的情况下，才按b来排序

  因此，a是有序的1，1，2，3，3，而b是全局无序，局部相对有序的状态

  从全局来看，b的值是无序的，因此直接执行b=2，无法利用索引。

  从局部来看，当a的值确定时，b是有序的，因此执行a = 1 and b =2时，a,b字段能用到索引，而执行a>1 and b = 2时，a字段能用到索引，b字段用不到索引。因为a的值是一个范围，不是固定的，在这个范围内b值不是有序的，因此b字段用不上索引。

  因此在遇到范围查询时，就会停止匹配。

  实战：

  ```mysql
  SELECT * FROM table WHERE a = 1 and b = 2 and c = 3;
  ```

  如何建立索引？

  （a,b,c）/(b,a,c)/(c,b,a)等都行，重点是将区分度高的字段放在前面，区分度低的放后面

  ```mysql
  SELECT * FROM table WHERE a > 1 and b = 2; 
  ```

对（b,a）建立索引，选择（a,b）碰到范围查询b就走不了索引

```mysql
       SELECT * FROM `table` WHERE a > 1 and b = 2 and c > 3;
```

(b,a)或（b,c)           

```mysql
       SELECT * FROM `table` WHERE a = 1 ORDER BY b;
```

对a建立索引，因为a的值是一个范围，这个范围内的b是无序的，没必要对（a,b）建立索引  

```mysql
       SELECT * FROM `table` WHERE a IN (1,2,3) and b > 1; 
```

(a,b)

###### 数据库三范式

1. **第一范式：** 确保每列的原子性，每列都是不可分割的最小数据单元,就是说一个字段只能存储一项信息
2. **第二范式：** 在第一范式的基础上，要求每列都和主键相关（完全依赖，直接间接都可以，如果不完全依赖可以拆分）
3. **第三范式：** 在第二范式的基础上，要求其他列和主键是直接相关，而不是间接相关，如果是间接的就应该考虑拆分。

分别说一下范式和反范式的优缺点？

范式

- 范式化的更新操作通常比反范式化要快
- 当数据较好地范式化时，就只有很少或者没有重复数据，所以只需要修改更少的数据
- 范式化的表通常更小，可以更好地放在内存里，所以执行操作会更快
- 更少地使用DISTINCT或者GROUP BY
- 范式化缺点：在查询时通常需要很多的关联，降低性能

反范式

- 反范式化的schema因为所有的数据都在一张表中，可以很好地避免关联
- 数据重复冗余，对数据库的修改需要更多的成本

###### Innodb的特点

- 支持事务，采用MVCC来支持高并发，并且实现了四个标准的隔离级别，默认级别是可重复读，并且通过间隙锁策略防止幻读的出现
- Innodb表基于聚簇索引建立，聚簇索引对主键查询有很高的性能，不过它的二级索引中必须包含主键列。
- Innodb的存储格式是平台独立的
- 支持外键约束

###### Innodb的索引页

<center><img src="https://cdn.jsdelivr.net/gh/nanxi1234/nanxi1234.github.io/image/2021/20210915202305.jpeg" alt="img" style="zoom:67%;" /></center>

<center><img src="https://cdn.jsdelivr.net/gh/nanxi1234/nanxi1234.github.io/image/2021/20210915202928.jpeg" alt="img" style="zoom:67%;" /></center>

###### Innodb行锁(Record Lock)实现

- 通过给索引上的索引项加锁来实现，只有通过索引条件检索数据，Innodb才使用行级锁，否则Innodb将会使用表锁。

- 对有索引的键值加锁，会对所有涉及到的数据行加锁

###### （Gap Lock）间隙锁

当用范围条件而不是想等条件检索数据，并请求共享或者排他锁时，Innodb对在范围内的数据记录的索引项加锁，对于不在范围内的但不存在的记录，叫做"间隙"，Innodb也会对这个间隙加锁，这就是间隙锁，它可以防止幻读的产生。

###### Next-key Lock

行锁+gap锁

###### mysql不走索引的原因？

- 索引列参与了运算
- 索引列使用了函数
- 索引列使用%like（走全表）

###### 什么时候会触发表锁？

- 涉及带有筛选条件的语句，如果筛选条件中没有用到索引，就会触发全表扫描
- 全表更新：事务需要更新大部分或全部数据，且表又比较大。若使用行锁，会导致事务执行效率低，从而可能造成其他事务长时间锁等待和更多的锁冲突。
- 多表查询：事务涉及多个表，比较复杂的关联查询，很可能引起死锁，造成大量事务回滚。这种情况若能一次性锁定事务涉及的表，从而可以避免死锁、减少数据库因事务回滚带来的开销。

##### 数据库comment表的内容

id:主键

user_id:用户id，评论是谁发布的

entity_type：评论目标的类别，如帖子、评论、用户等

entity_id：这个类型的目标具体是哪个目标

target_id：针对指向的人的id

content：评论内容

status：0正常；1禁用

###### Nginx进程模型

- master进程：主进程，接受外界的信号，分发给worker，如果worker发生异常，会重新启动新的worker

- worker进程：工作进程，执行master的业务。

<img src="https://cdn.jsdelivr.net/gh/nanxi1234/nanxi1234.github.io/image/2021/20210815163856.png" alt="image-20210815163849701" style="zoom:80%;" />

###### woker抢占机制

![image-20210815164301439](https://cdn.jsdelivr.net/gh/nanxi1234/nanxi1234.github.io/image/2021/20210815164301.png)

与传统服务器事件处理相比：

![image-20210815164404546](https://cdn.jsdelivr.net/gh/nanxi1234/nanxi1234.github.io/image/2021/20210815164404.png)

为什么nginx的性能这么高？抢占机制以及epoll模型的异步非阻塞的通信模式（高效），多路复用器。

###### nginx.conf配置结构

![image-20210815165612403](https://cdn.jsdelivr.net/gh/nanxi1234/nanxi1234.github.io/image/2021/20210815165612.png)

