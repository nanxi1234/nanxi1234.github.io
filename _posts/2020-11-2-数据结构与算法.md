---
date: 2020-11-02 16:10:40
layout: post
title: 数据结构与算法
subtitle: 
image: https://user-images.githubusercontent.com/67684652/97844439-fd8ffe80-1d25-11eb-9a07-474ae4fff40f.jpg
optimized_image: https://user-images.githubusercontent.com/67684652/97844439-fd8ffe80-1d25-11eb-9a07-474ae4fff40f.jpg
category: 算法
tags:
  - 数据结构
  - 算法
author: 张朝晖
---

# <center>算法四笔记</center>

## 一.输入与输出

默认状态下系统会将标准输出定向到终端窗口，Debug时输入的内容就是输入流，但是输入流的特点是这些值会在被读取之后消失。

- 重定向：%java RandomSeq 1000 100.0 200.0>data.txt



<center><img src="https://cdn.jsdelivr.net/gh/nanxi1234/nanxi1234.github.io/image/2021/20210314190144.png"/></center>

 输入被写入一个data.txt的文件

<center><img src="https://cdn.jsdelivr.net/gh/nanxi1234/nanxi1234.github.io/image/2021/20210314102601.png" alt="image-20210307195840729"  /></center>


​        用data.txt中的数据 作为输入，求其平均值   

- 管道：将一个程序的输出重定向为另一个程序的输入叫做管道

  <center><img src="https://cdn.jsdelivr.net/gh/nanxi1234/nanxi1234.github.io/image/2021/20210314102914.png" alt="image-20210307210837943" style="zoom:80%;" /></center>

RandomSeq=>标准输入=>标准输出=>Average

## 二.算法复杂度分析

### 2.1 增长数量级的分类

#### 2.1.1 常数级别(1)

运行时间不依赖N，例如b=a[N]

#### 2.1.2 对数级别(log N)

运行时间和问题规模呈对数关系的程序，经典例子：二分查找（N=2^x,x=log2N）

#### 2.1.3 线性级别(N)

使用常数时间处理处理输入数据的所有元素或是基于单个for循环，与N呈线性

#### 2.1.4 线性对数级别（N log N）

归并算法和快速排序

#### 2.1.5 平方级别(N^2^)

常见的两个嵌套的for循环

#### 2.1.6 立方级别(N^3^)

常见的三层for循环
### 2.2 设计更快速的算法

  



## 三.背包&队列&栈

### 3.1 背包（Bag）

​    背包是一种不支持从中删除元素的集合数据类型

- 作用：收集元素并迭代遍历所有收集到的元素，迭代的顺序不确定且与用例无关

### 3.2 先进先出队列（FIFO queue）

- 作用：在用集合保存元素时同时保持它们的相对顺序，即入列顺序和出列顺序相同

### 3.3栈（LIFO）

举个例子：点击一个链接，浏览器会弹出一个新界面并将它压入一个栈，当你点击回退时，上一个界面从栈里弹出

- 当用例使用foreach语句迭代遍历栈中的元素时，元素的处理顺序于他被压入栈的时间正好相反。在应用程序中使用栈迭代器可以在保存集合的同时颠倒它们的相对顺序。

## 四.容器

### 4.1 链表（linked list）

链表将每个对象存放在单独的链接(link)中，每个链接中还存放着序列中下个链接的引用

为什么要使用列表？

尽可能减少在列表中间插入或删除元素的开销


### 4.2 散列表（HashMap)
#### 4.2.1 什么是散列表？
将*键作为数组的索引*而数组中键i处存储的就是它对应的值，这样我们就能快速访问任意键的值！

#### 4.2.2 如何将键转化为数组的索引？（关键问题一）

利用哈希函数，对于每种类型的键我们都需要与之对应的哈希函数，选择哈希函数的原则：易于计算并且能够均匀分布所有的键。

#### 4.2.3 散列表的优缺点

使用散列表，可以实现在一般应用中拥有常数级别的查找和插入操作的符号表；散列表的核心问题：处理碰撞冲突——-我们想它不同键对应不同的索引值，但是事实是我们必须面对不同的键都会散列到相同的索引值的情况（在时间和空间的权衡下所产生的结果）

#### 4.3.4 HashCode()

HashCode()方法返回一个32比特整数；如果a.equals(b)方法返回True，那么HashCode(a)的返回值必然和HashCode(b)相等，反推不一定。

- 将HashCode()的返回值转化为数组索引
- 对于任意对象X，可调用X.hashCode()并认为有均等的机会 得到2^32个不同整数中的任意一个32位整数值，在java中，所有数据类型都继承hashCode()方法。
- 软缓存：如果散列值的计算很耗时(也就意味着每算一次都很耗时，最好算完之后后面不要再算了，用空间换时间！)，我们可以用一个hash变量来保存它的HashCode()的返回值，这样我们算完一次 返回值→散列值之后，以后再次调用HashCode()就不用再次计算。

#### 4.3.5 碰撞处理（关键问题二）

- 拉链法：将大小为M的数组中的每一个元素指向一条链表，每个结点都存储了散列值为该元素索引的键值对，发生冲突的元素都被都被存储在链表中，我们通过选择足够大的M(链表的平均长度为N/M)，使链表尽可能短以便我们查找（空间换时间）。

#### 5 二进制问题

##### 5.1 逻辑与算术移动

逻辑右移：不考虑符号位，左边统一补零。

算术右移：考虑符号位，右移一位，若符号位为1，则左边补1；若符号位为0,则左边补0。

逻辑&&算术左移：右边统一补0。

eg.    1010101010

| 逻辑右移一位 | [0]101010101 |
| :----------: | :----------: |
| 算术右移一位 | [1]101010101 |
| 逻辑左移一位 | 010101010[0] |
| 算术右移一位 | 010101010[0] |

##### 位运算符

|  &   |      同1为1      |
| :--: | :--------------: |
|  \|  |     有1则为1     |
|  ~   |       取反       |
|  ^   | 相同为1，不同为0 |

#### 6 排序算法

##### 6.1排序成本模型：

评估排序算法的性能，首先，要计算不同算法在不同随机输入下的基本操作的次数（包括比较和交换，或者是读写数组的次数）

排序算法可以分为两类：

① 除了函数调用所需的栈和固定数目的实例变量之外无需额外内存的原地排序算法

② 需要额外内存空间来存储另一份数组副本的其他排序算法

#### 6.2 排序算法

##### 6.2.1 选择排序

每次从数组里面找出最小的值，将它与数组的第一个数交换。

性能分析：对于长度为N的数组，选择排序需要大约N^2^/2次比较和N次交换。

特点：① 运行时间与输入无关

​            ② 数据移动是最少的

##### 6.2.2 插入排序

如果a[i]>a[i+1]则交换这两个数，不断交换，直到有序

改进：不交换的插入排序，若a[i]>a[i+1],则让大的数往右移

特点：运行时间与输入有关，最坏情况下与选择排序一样，平均情况下是选择排序的一半

##### 6.2.3 希尔排序

引出（为什么需要希尔排序）：对于大规模的乱序排序，插入排序比较慢，因为他只会交换相邻的元素，因此元素只能一点一点地从数组的一端到另一端，若主键最小的元素正好在数组的尽头，要将它移动到正确的位置上就需要N-1次移动。

最初的想法：希尔排序为了**加快速度**简单地改进了插入排序，交换不相邻的元素对数组的局部进行排序，并最终用插入排序将局部有序的数组派序。

思想：让数组中任意间隔为h的元素都是有序的，一个h有序数组就是h个互相独立的有序数组编织在一起组成的一个数组；如果h很大，我们就能将元素移动到很远的地方，为实现更小的h有序创造方便。减少了插入排序的移动次数。

实现方式：对每个h，用插入排序将h个子数组独立地进行排序，在h-子数组中将每个元素交换到比它大的元素之前去(将比他大的元素向右移动)，只需将插入排序移动的距离改为h即可（这样就实现了一次移动h距离，加快了速度）

##### 6.2.4 归并排序

思想：要将一个数组排序，可以先将它分为两半分别排序，然后将结果归并起来

优点：对于任意长度为N的数组，排序时间与N log N成正比

原地归并：先将前半部分排序，再将后半部分排序，然后在数组中移动元素而不需要额外的空间

![image-20210331161655587](https://cdn.jsdelivr.net/gh/nanxi1234/nanxi1234.github.io/image/2021/20210331161655.png)

合并

![image-20210331161410162](https://cdn.jsdelivr.net/gh/nanxi1234/nanxi1234.github.io/image/2021/20210331161410.png)

```java
package edu.princeton.cs.algs4;

public class SortDemo4 {
    
          public static void merge(Comparable[] a,int lo,int mid,int hi)
        {     Comparable[] aux=new Comparable[a.length];
              int i=lo,j=mid+1;
              for(int k=lo;k<=hi;k++)
              {
                  aux[k]=a[k];
              }
            for(int k=lo;k<=hi;k++)
            {
                if(i>mid) a[k]=a[j++];
                else if(j>hi) a[k]=aux[i++];
                else if(less(aux[j],aux[i])) a[k]=aux[j++];
                else a[k]=aux[i++];
            }
    }
    
    private static Comparable[] aux;//所需的辅助数组
    public static void sort(Comparable[] a)
    {
        aux=new Comparable[a.length];
        sort(a,0,a.length-1);
    }
    
    public static void sort(Comparable[] a,int lo,int hi)
    {
        //将数组a[lo...hi排序]
        if(hi<=lo) return;
        int mid=lo+(hi-lo)/2;
        sort(a,lo,mid);//递归左半边排序
        sort(a,mid+1,hi);//右半边排序
        merge(a,lo,mid,hi);//归并
    }


    private static boolean less(Comparable v,Comparable w)//测试是否有序
    {
        return v.compareTo(w)<0;//
    }
    private static void exch(Comparable[] a,int i,int j)//交换位置
    {
        Comparable t=a[i];a[i]=a[j];a[j]=t;
    }
    private static void show(Comparable[] a)//打印
    {
        for(int i=0;i<a.length;i++)
            StdOut.print(a[i]+"");
        StdOut.println();
    }
    public static boolean isSortd(Comparable[] a)//测试是否已有序
    {
        for(int i=1;i<a.length;i++) {
            if (less(a[i], a[i - 1]))
                return false;
        }
            return true;
        }
        
    public static void main(String[] args) {
        String[] a = new In("tiny.txt").readAllStrings();
        sort(a);
        if(!isSortd(a))
            System.out.println("false");
          else show(a);

    }
}
```

改进：

- 因为递归会使小规模问题中方法的调用过于频繁，所以改进对它们的处理方法就能改进整个算法
- 若a[mid]<a[mid+1]，则说明有序，跳过merge（两个有序的只要   其中一个的尾a[mid]>其中一个的头a[mid+1]，则说明他们合成之后也是有序的）这对任意有序的子数组而言，算法的运行时间就是线性的了。
- 节省将数组元素复制到用于归并的辅助数组所用的时间；在递归调用的每一个层次交换输入数组和辅助数组的角色。（*）

##### 6.2.5 快速排序

