---
date: 2020-11-02 16:10:40
layout: post
title: 数据结构与算法
subtitle: 
image: https://user-images.githubusercontent.com/67684652/97844439-fd8ffe80-1d25-11eb-9a07-474ae4fff40f.jpg
optimized_image: https://user-images.githubusercontent.com/67684652/97844439-fd8ffe80-1d25-11eb-9a07-474ae4fff40f.jpg
category: 算法
tags:
  - 数据结构
  - 算法
author: 张朝晖
---

# <center>算法四笔记</center>

## 一.输入与输出

默认状态下系统会将标准输出定向到终端窗口，Debug时输入的内容就是输入流，但是输入流的特点是这些值会在被读取之后消失。

- 重定向：%java RandomSeq 1000 100.0 200.0>data.txt



<center><img src="https://cdn.jsdelivr.net/gh/nanxi1234/nanxi1234.github.io/image/2021/20210314190144.png"/></center>

 输入被写入一个data.txt的文件

<center><img src="https://cdn.jsdelivr.net/gh/nanxi1234/nanxi1234.github.io/image/2021/20210314102601.png" alt="image-20210307195840729"  /></center>


​        用data.txt中的数据 作为输入，求其平均值   

- 管道：将一个程序的输出重定向为另一个程序的输入叫做管道

  <center><img src="https://cdn.jsdelivr.net/gh/nanxi1234/nanxi1234.github.io/image/2021/20210314102914.png" alt="image-20210307210837943" style="zoom:80%;" /></center>

RandomSeq=>标准输入=>标准输出=>Average

## 二.算法复杂度分析

### 2.1 增长数量级的分类

#### 2.1.1 常数级别(1)

运行时间不依赖N，例如b=a[N]

#### 2.1.2 对数级别(log N)

运行时间和问题规模呈对数关系的程序，经典例子：二分查找（N=2^x,x=log2N）

#### 2.1.3 线性级别(N)

使用常数时间处理处理输入数据的所有元素或是基于单个for循环，与N呈线性

#### 2.1.4 线性对数级别（N log N）

归并算法和快速排序

#### 2.1.5 平方级别(N^2^)

常见的两个嵌套的for循环

#### 2.1.6 立方级别(N^3^)

常见的三层for循环
### 2.2 设计更快速的算法

  



## 三.背包&队列&栈

### 3.1 背包（Bag）

​    背包是一种不支持从中删除元素的集合数据类型

- 作用：收集元素并迭代遍历所有收集到的元素，迭代的顺序不确定且与用例无关

### 3.2 先进先出队列（FIFO queue）

- 作用：在用集合保存元素时同时保持它们的相对顺序，即入列顺序和出列顺序相同

### 3.3栈（LIFO）

举个例子：点击一个链接，浏览器会弹出一个新界面并将它压入一个栈，当你点击回退时，上一个界面从栈里弹出

- 当用例使用foreach语句迭代遍历栈中的元素时，元素的处理顺序于他被压入栈的时间正好相反。在应用程序中使用栈迭代器可以在保存集合的同时颠倒它们的相对顺序。

## 四.容器

### 4.1 链表（linked list）

链表将每个对象存放在单独的链接(link)中，每个链接中还存放着序列中下个链接的引用

为什么要使用列表？

尽可能减少在列表中间插入或删除元素的开销


### 4.2 散列表（HashMap)
#### 4.2.1 什么是散列表？
将*键作为数组的索引*而数组中键i处存储的就是它对应的值，这样我们就能快速访问任意键的值！

#### 4.2.2 如何将键转化为数组的索引？（关键问题一）

利用哈希函数，对于每种类型的键我们都需要与之对应的哈希函数，选择哈希函数的原则：易于计算并且能够均匀分布所有的键。

#### 4.2.3 散列表的优缺点

使用散列表，可以实现在一般应用中拥有常数级别的查找和插入操作的符号表；散列表的核心问题：处理碰撞冲突——-我们想它不同键对应不同的索引值，但是事实是我们必须面对不同的键都会散列到相同的索引值的情况（在时间和空间的权衡下所产生的结果）

#### 4.3.4 HashCode()

HashCode()方法返回一个32比特整数；如果a.equals(b)方法返回True，那么HashCode(a)的返回值必然和HashCode(b)相等，反推不一定。

- 将HashCode()的返回值转化为数组索引
- 对于任意对象X，可调用X.hashCode()并认为有均等的机会 得到2^32个不同整数中的任意一个32位整数值，在java中，所有数据类型都继承hashCode()方法。
- 软缓存：如果散列值的计算很耗时(也就意味着每算一次都很耗时，最好算完之后后面不要再算了，用空间换时间！)，我们可以用一个hash变量来保存它的HashCode()的返回值，这样我们算完一次 返回值→散列值之后，以后再次调用HashCode()就不用再次计算。

#### 4.3.5 碰撞处理（关键问题二）

- 拉链法：将大小为M的数组中的每一个元素指向一条链表，每个结点都存储了散列值为该元素索引的键值对，发生冲突的元素都被都被存储在链表中，我们通过选择足够大的M(链表的平均长度为N/M)，使链表尽可能短以便我们查找（空间换时间）。

#### 4.3.6 API及例题

- **boolean contains(Object value)**
   测试此映射表中是否存在与指定值关联的键。

- **boolean containsKey(Object key)**
  测试指定对象是否为此哈希表中的键

- **Object get(Object key)**   

  返回指定键所映射到的值，如果此映射不包含此键的映射，则返回 null.

- **Object put(Object key, Object value)**
  将指定 key 映射到此哈希表中的指定 value。

- 例题：两数之和

```java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        Map<Integer, Integer> hashtable = new HashMap<>();
        for (int i = 0; i < nums.length - 1; i++) {
            if (hashtable.containKey(target - nums[i])) {
                return new int[]{hashtable.get(target - nums[i]), i};
            }
            hashtable.put(nums[i], i);
        }
        return new int[0];
    }
}
```

#### 5 二进制问题

##### 5.1 逻辑与算术移动

逻辑右移：不考虑符号位，左边统一补零。

算术右移：考虑符号位，右移一位，若符号位为1，则左边补1；若符号位为0,则左边补0。

逻辑&&算术左移：右边统一补0。

eg.    1010101010

| 逻辑右移一位 | [0]101010101 |
| :----------: | :----------: |
| 算术右移一位 | [1]101010101 |
| 逻辑左移一位 | 010101010[0] |
| 算术右移一位 | 010101010[0] |

##### 位运算符

|  &   |      同1为1      |
| :--: | :--------------: |
|  \|  |     有1则为1     |
|  ~   |       取反       |
|  ^   | 相同为1，不同为0 |

#### 6 排序算法

##### 6.1排序成本模型：

评估排序算法的性能，首先，要计算不同算法在不同随机输入下的基本操作的次数（包括比较和交换，或者是读写数组的次数）

排序算法可以分为两类：

① 除了函数调用所需的栈和固定数目的实例变量之外无需额外内存的原地排序算法

② 需要额外内存空间来存储另一份数组副本的其他排序算法

#### 6.2 排序算法

##### 6.2.1 选择排序

每次从数组里面找出最小的值，将它与数组的第一个数交换。

性能分析：对于长度为N的数组，选择排序需要大约N^2^/2次比较和N次交换。

特点：① 运行时间与输入无关

​            ② 数据移动是最少的

##### 6.2.2 插入排序

如果a[i]>a[i+1]则交换这两个数，不断交换，直到有序

改进：不交换的插入排序，若a[i]>a[i+1],则让大的数往右移

特点：运行时间与输入有关，最坏情况下与选择排序一样，平均情况下是选择排序的一半

##### 6.2.3 希尔排序

引出（为什么需要希尔排序）：对于大规模的乱序排序，插入排序比较慢，因为他只会交换相邻的元素，因此元素只能一点一点地从数组的一端到另一端，若主键最小的元素正好在数组的尽头，要将它移动到正确的位置上就需要N-1次移动。

最初的想法：希尔排序为了**加快速度**简单地改进了插入排序，交换不相邻的元素对数组的局部进行排序，并最终用插入排序将局部有序的数组派序。

思想：让数组中任意间隔为h的元素都是有序的，一个h有序数组就是h个互相独立的有序数组编织在一起组成的一个数组；如果h很大，我们就能将元素移动到很远的地方，为实现更小的h有序创造方便。减少了插入排序的移动次数。

实现方式：对每个h，用插入排序将h个子数组独立地进行排序，在h-子数组中将每个元素交换到比它大的元素之前去(将比他大的元素向右移动)，只需将插入排序移动的距离改为h即可（这样就实现了一次移动h距离，加快了速度）

##### 6.2.4 归并排序

思想：要将一个数组排序，可以先将它分为两半分别排序，然后将结果归并起来

优点：对于任意长度为N的数组，排序时间与N log N成正比

原地归并：先将前半部分排序，再将后半部分排序，然后在数组中移动元素而不需要额外的空间

![image-20210331161655587](https://cdn.jsdelivr.net/gh/nanxi1234/nanxi1234.github.io/image/2021/20210331161655.png)

合并

![image-20210331161410162](https://cdn.jsdelivr.net/gh/nanxi1234/nanxi1234.github.io/image/2021/20210331161410.png)

```java
package edu.princeton.cs.algs4;

public class SortDemo4 {
    
          public static void merge(Comparable[] a,int lo,int mid,int hi)
        {     Comparable[] aux=new Comparable[a.length];
              int i=lo,j=mid+1;
              for(int k=lo;k<=hi;k++)
              {
                  aux[k]=a[k];
              }
            for(int k=lo;k<=hi;k++)
            {
                if(i>mid) a[k]=a[j++];
                else if(j>hi) a[k]=aux[i++];
                else if(less(aux[j],aux[i])) a[k]=aux[j++];
                else a[k]=aux[i++];
            }
    }
    
    private static Comparable[] aux;//所需的辅助数组
    public static void sort(Comparable[] a)
    {
        aux=new Comparable[a.length];
        sort(a,0,a.length-1);
    }
    
    public static void sort(Comparable[] a,int lo,int hi)
    {
        //将数组a[lo...hi排序]
        if(hi<=lo) return;
        int mid=lo+(hi-lo)/2;
        sort(a,lo,mid);//递归左半边排序
        sort(a,mid+1,hi);//右半边排序
        merge(a,lo,mid,hi);//归并
    }


    private static boolean less(Comparable v,Comparable w)//测试是否有序
    {
        return v.compareTo(w)<0;//
    }
    private static void exch(Comparable[] a,int i,int j)//交换位置
    {
        Comparable t=a[i];a[i]=a[j];a[j]=t;
    }
    private static void show(Comparable[] a)//打印
    {
        for(int i=0;i<a.length;i++)
            StdOut.print(a[i]+"");
        StdOut.println();
    }
    public static boolean isSortd(Comparable[] a)//测试是否已有序
    {
        for(int i=1;i<a.length;i++) {
            if (less(a[i], a[i - 1]))
                return false;
        }
            return true;
        }
        
    public static void main(String[] args) {
        String[] a = new In("tiny.txt").readAllStrings();
        sort(a);
        if(!isSortd(a))
            System.out.println("false");
          else show(a);

    }
}
```

改进：

- 因为递归会使小规模问题中方法的调用过于频繁，所以改进对它们的处理方法就能改进整个算法
- 若a[mid]<a[mid+1]，则说明有序，跳过merge（两个有序的只要   其中一个的尾a[mid]>其中一个的头a[mid+1]，则说明他们合成之后也是有序的）这对任意有序的子数组而言，算法的运行时间就是线性的了。
- 节省将数组元素复制到用于归并的辅助数组所用的时间；在递归调用的每一个层次交换输入数组和辅助数组的角色。（*）



------------------------------------------------


##### 6.2.5 快速排序

 归并排序和快速排序是互补的；归并排序将数组等分为两个子数组，分别将它们排序后再归并。而快速排序是选主元然后使左右两边都有序，整个数组自然就有序了。

```java


```



#####  6.2.6 堆排序

```java
//构造大根堆（通过新插入的数上升）
public static void heapInsert(int[] arr) {
    for (int i = 0; i < arr.length; i++) {
        //当前插入的索引
        int currentIndex = i;
        //父结点索引
        int fatherIndex = (currentIndex - 1) / 2;
        //如果当前插入的值大于其父结点的值,则交换值，并且将索引指向父结点
        //然后继续和上面的父结点值比较，直到不大于父结点，则退出循环
        while (arr[currentIndex] > arr[fatherIndex]) {
            //交换当前结点与父结点的值
            swap(arr, currentIndex, fatherIndex);
            //将当前索引指向父索引
            currentIndex = fatherIndex;
            //重新计算当前索引的父索引
            fatherIndex = (currentIndex - 1) / 2;
        }
    }
}
```

```java
public static void heapify(int[] arr, int index, int size) {//下沉排序
    int left = 2 * index + 1;
    int right = 2 * index + 2;
    while (left < size) {
        int largestIndex;
        //判断孩子中较大的值的索引（要确保右孩子在size范围之内）
        if (arr[left] < arr[right] && right < size) {
            largestIndex = right;
        } else {
            largestIndex = left;
        }
        //比较父结点的值与孩子中较大的值，并确定最大值的索引
        if (arr[index] > arr[largestIndex]) {
            largestIndex = index;
        }
        //如果父结点索引是最大值的索引，那已经是大根堆了，则退出循环
        if (index == largestIndex) {
            break;
        }
        //父结点不是最大值，与孩子中较大的值交换
        swap(arr, largestIndex, index);
        //将索引指向孩子中较大的值的索引
        index = largestIndex;
        //重新计算交换之后的孩子的索引
        left = 2 * index + 1;
        right = 2 * index + 2;
    }

}
```

```java
public static void swap(int[] arr, int i, int j) {//和两个孩子中较大的孩子交换
    int temp = arr[i];
    arr[i] = arr[j];
    arr[j] = temp;
}
```

#### 7.树

##### 7.1 前缀树

前缀树是一种树形数据结构，又称字典树，用于高效地存储和检索字符串数据集中的键。常用于自动补完和拼写检查。假设，我们要设计一个翻译软件，翻译软件少不了查词功能，而且当用户输入要查询的词汇时，软件会提示相似单词，让用户选择要查询的词汇，这样用户就无需输入完整词汇就能进行查询，而且用户体验更好。

![image-20210414144950654](https://cdn.jsdelivr.net/gh/nanxi1234/nanxi1234.github.io/image/2021/20210414144957.png)

其每个节点包含以下字段

- 指向子节点的指针数组children，例如26个小写字母的数组
- ![image-20210414162002001](https://cdn.jsdelivr.net/gh/nanxi1234/nanxi1234.github.io/image/2021/20210414162002.png)
- 布尔字段isEnd，判断结点是否为字符串的结尾

Leetcode 208题：

实现trie（前缀树）

```java
class Trie {
       private boolean isEnd;
       private Trie[] children;//定义两个前缀树的字段
    /** Initialize your data structure here. */
    public Trie() {//定义节点
     isEnd=false;
     children=new Trie[26];
    }
    
    /** Inserts a word into the trie. */
    public void insert(String word) {
        Trie node=this;//Trie类型的节点的根节点是第一个输入，即null
       for(int i=0;i<word.length();i++)
       {
           int index=word.charAt(i)-'a';
           if(node.children[index]==null)//代表该字符的节点为空
           {
            node.children[index]=new Trie();//创建节点
           }
              node=node.children[index];    //下一个
       }
           node.isEnd=true;//循环结束，字符串到尾
    }
    
    /** Returns if the word is in the trie. */
    public boolean search(String word) {
        Trie node=searchword(word);
         return (node != null && node.isEnd);
    }
    
    /** Returns if there is any word in the trie that starts with the given prefix. */
    public boolean startsWith(String prefix) {
           return searchword(prefix) != null;//不用判断是不是到头了，因为只用搜索前x个字母是否相同
    }
    public Trie searchword(String word)
    {
        Trie node=this;
        for(int i=0;i<word.length();i++)
        {
            int index=word.charAt(i)-'a';
            if(node.children[index] == null)
            {
                return null;
            }
            node=node.children[index];
        }
        return node;
    }
}
```

#### 8.Map

##### 8.1 TreeSet

![image-20210418210230208](https://cdn.jsdelivr.net/gh/nanxi1234/nanxi1234.github.io/image/2021/20210418210237.png)



TreeSet是一个有序的集合，它的作用是提供有序的Set集合，TreeSet的元素支持两种排序方式：自然排序或者根据提供的Comparator进行排序（重写CompareTo方法）。

CompareTo方法：

- 返回值为0——存一个元素

- 返回-1——倒序存储
- 返回1——顺序存储

Why？

TreeSet底层是一个二叉树，每插入一个新元素（第一个元素除外）都会调用CompareTo方法和上一个插入的元素作比较，并按照二叉树的结构进行排列。

- 如果将CompareTo()返回值写死为0；元素值每次比较，都认为是相同的元素，这时就不再向TreeSet中插入除第一个外的新元素，所以TreeSet中就只存在插入的第一个元素。
- 若为1，则每次比较，都认为新插入的元素比上一个元素大，于是二叉树存储时，会存在根的右侧，读取的时候就是正序排列的。
- 若为-1，元素值每次比较，都认为新插入的元素比上一个元素小，于是二叉树存储时，会在根的左侧，读取时(中序遍历)就是倒序排列的。

#### 9.深度优先搜索(DFS)&&宽度优先搜索(BFS)

##### 9.1深度优先搜索

- 非递归实现：用栈实现，对于每个节点，先遍历当前节点，然后把右节点压栈，再压左节点，根据栈后入先出的特点，弹出时会先遍历左节点，符合深度优先遍历的要求。

  使用栈来将要遍历的节点压栈，然后出栈后检查此节点是否还有未遍历的子节点，有的话继续压栈，没有的话则不断出栈。

具体实现：

```java
package DemoDS;

import java.util.Stack;

class TreeNode {
    int val;
    TreeNode left;
    TreeNode right;

    TreeNode(int x) {
        val = x;
    }
}
public class DemoDFS {
    //使用栈来将要遍历的节点压栈，然后出栈后检查此节点是否还有未遍历的子节点，有的话继续压栈，没有的话则不断出栈。
    public static void DemoStackDFS(TreeNode root)//DFS实现
    {
        if(root==null) return;
        Stack<TreeNode> stack=new Stack<>();
        stack.push(root);
        while(!stack.isEmpty())
        {
            TreeNode pop= stack.pop();
            System.out.print(pop.val);
            if(pop.right != null)
            {
               stack.push(pop.right);
            }
            if(pop.left != null)
            {
                stack.push(pop.left);
            }
        }
    }
    public static TreeNode buildTree(int[] nums, int i){//建树操作
        if(nums.length==0)
            return null;
        if(i>=nums.length)
            return null;
        TreeNode root = new TreeNode(nums[i]);
        root.left = buildTree(nums,2*i+1);
        root.right = buildTree(nums,2*i+2);
        return root;
    }

    public static void main(String[] args) {
        int[] data={4,3,7,9,2,1};
        DemoStackDFS(buildTree(data,0));
    }
}

Result:
DemoDS.DemoDFS
439271
Process finished with exit code 0

```