---
date: 2020-11-02 16:10:40
layout: post
title: 数据结构与算法
subtitle: 
image: https://user-images.githubusercontent.com/67684652/97844439-fd8ffe80-1d25-11eb-9a07-474ae4fff40f.jpg
optimized_image: https://user-images.githubusercontent.com/67684652/97844439-fd8ffe80-1d25-11eb-9a07-474ae4fff40f.jpg
category: 算法
tags:
  - 数据结构
  - 算法
author: 张朝晖
---

# <center>算法四笔记</center>

## 一.输入与输出

默认状态下系统会将标准输出定向到终端窗口，Debug时输入的内容就是输入流，但是输入流的特点是这些值会在被读取之后消失。

- 重定向：%java RandomSeq 1000 100.0 200.0>data.txt



<center><img src="https://cdn.jsdelivr.net/gh/nanxi1234/nanxi1234.github.io/image/2021/20210314190144.png"/></center>

 输入被写入一个data.txt的文件

<center><img src="https://cdn.jsdelivr.net/gh/nanxi1234/nanxi1234.github.io/image/2021/20210314102601.png" alt="image-20210307195840729"  /></center>


​        用data.txt中的数据 作为输入，求其平均值   

- 管道：将一个程序的输出重定向为另一个程序的输入叫做管道

  <center><img src="https://cdn.jsdelivr.net/gh/nanxi1234/nanxi1234.github.io/image/2021/20210314102914.png" alt="image-20210307210837943" style="zoom:80%;" /></center>

RandomSeq=>标准输入=>标准输出=>Average

## 二.背包&队列&栈

### 2.1 背包（Bag）

​    背包是一种不支持从中删除元素的集合数据类型

- 作用：收集元素并迭代遍历所有收集到的元素，迭代的顺序不确定且与用例无关

### 2.2 先进先出队列（FIFO queue）

- 作用：在用集合保存元素时同时保持它们的相对顺序，即入列顺序和出列顺序相同

### 2.3栈（LIFO）

举个例子：点击一个链接，浏览器会弹出一个新界面并将它压入一个栈，当你点击回退时，上一个界面从栈里弹出

- 当用例使用foreach语句迭代遍历栈中的元素时，元素的处理顺序于他被压入栈的时间正好相反。在应用程序中使用栈迭代器可以在保存集合的同时颠倒它们的相对顺序。

## 三.容器

### 3.1 链表（linked list）

链表将每个对象存放在单独的链接(link)中，每个链接中还存放着序列中下个链接的引用

为什么要使用列表？

尽可能减少在列表中间插入或删除元素的开销


### 3.2 散列表（HashMap)
#### 3.2.1 什么是散列表？
将*键作为数组的索引*而数组中键i处存储的就是它对应的值，这样我们就能快速访问任意键的值！

#### 3.2.2 如何将键转化为数组的索引？（关键问题一）

利用哈希函数，对于每种类型的键我们都需要与之对应的哈希函数，选择哈希函数的原则：易于计算并且能够均匀分布所有的键。

#### 3.2.3 散列表的优缺点

使用散列表，可以实现在一般应用中拥有常数级别的查找和插入操作的符号表；散列表的核心问题：处理碰撞冲突——-我们想它不同键对应不同的索引值，但是事实是我们必须面对不同的键都会散列到相同的索引值的情况（在时间和空间的权衡下所产生的结果）

#### 3.3.4 HashCode()

HashCode()方法返回一个32比特整数；如果a.equals(b)方法返回True，那么HashCode(a)的返回值必然和HashCode(b)相等，反推不一定。

- 将HashCode()的返回值转化为数组索引
- 对于任意对象X，可调用X.hashCode()并认为有均等的机会 得到2^32个不同整数中的任意一个32位整数值，在java中，所有数据类型都继承hashCode()方法。
- 软缓存：如果散列值的计算很耗时(也就意味着每算一次都很耗时，最好算完之后后面不要再算了，用空间换时间！)，我们可以用一个hash变量来保存它的HashCode()的返回值，这样我们算完一次 返回值→散列值之后，以后再次调用HashCode()就不用再次计算。

#### 3.3.5碰撞处理（关键问题二）

- 拉链法：将大小为M的数组中的每一个元素指向一条链表，每个结点都存储了散列值为该元素索引的键值对，发生冲突的元素都被都被存储在链表中，我们通过选择足够大的M(链表的平均长度为N/M)，使链表尽可能短以便我们查找（空间换时间）。