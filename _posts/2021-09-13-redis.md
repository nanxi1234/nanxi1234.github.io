---

title: redis
---

###### Redis简介

Remote Dictionary Server(远程数据服务)，是一个基于内存且支持持久化的高性能key-value数据库，主要特征：

- 多数据类型
- 持久化机制
- 主从同步

###### Redis支持哪几种数据类型？

- String：字符串
- list：按添加顺序保持顺序的字符串列表
- set：无序的String集合
- sorted set（Zset）:已排序的String集合
- hash：key-value对的一种集合

###### Redis为什么是单线程？

多线程处理会涉及到锁，而且多线程处理会涉及到线程切换而消耗CPU，单线程的实现，CPU不会成为Redis的瓶颈，Redis的瓶颈最有可能是机器内存的大小或者网络带宽，既然单线程容易实现，而且CPU不会成为瓶颈，所以就采用单线程的方案。

- 不需要各种锁的性能消耗，避免同步操作带来的性能消耗
- 避免了线程切换而消耗CPU，减少了CPU消耗

###### Redis的线程模型

Redis内部使用文件事件处理器file event handler，这个文件处理器是单线程的，它采用IO多路复用机制同时监听多个socket，根据socket上的事件来选择对应的事件处理器进行处理。

文件事件处理器的结构包含4个部分：

- 多个socket
- IO复用程序
- 文件事件分派器
- 事件处理器（连接应答处理器，命令请求处理器，命令回复处理器）

多个socket可能会产生不同的操作，每个操作对应不同的文件事件，但是IO多路复用程序会监听多个socket，将socket产生的事件放入队列中排队，事件分派器每次从队列中取出一个事件，把该事件交给对应的事件处理器进行处理。

<center><img src="https://cdn.jsdelivr.net/gh/nanxi1234/nanxi1234.github.io/image/2021/20210917105630.png" alt="img" style="zoom:80%;" /></center>

<center><img src="https://cdn.jsdelivr.net/gh/nanxi1234/nanxi1234.github.io/image/2021/20210917105815.png" alt="img" style="zoom:80%;" /></center>

 建立连接

1. 首先，redis 服务端进程初始化的时候，会将 server socket 的 AE_READABLE 事件与连接应答处理器关联。
2. 客户端 socket01 向 redis 进程的 server socket 请求建立连接，此时 server socket 会产生一个 AE_READABLE 事件，IO 多路复用程序监听到 server socket 产生的事件后，将该 socket 压入队列中。
3. 文件事件分派器从队列中获取 socket，交给连接应答处理器。
4. 连接应答处理器会创建一个能与客户端通信的 socket01，并将该 socket01 的 AE_READABLE 事件与命令请求处理器关联。

 执行一个set请求

1. 客户端发送了一个 set key value 请求，此时 redis 中的 socket01 会产生 AE_READABLE 事件，IO 多路复用程序将 socket01 压入队列，
2. 此时事件分派器从队列中获取到 socket01 产生的 AE_READABLE 事件，由于前面 socket01 的 AE_READABLE 事件已经与命令请求处理器关联，
3. 因此事件分派器将事件交给命令请求处理器来处理。命令请求处理器读取 socket01 的 key value 并在自己内存中完成 key value 的设置。
4. 操作完成后，它会将 socket01 的 AE_WRITABLE 事件与命令回复处理器关联。
5. 如果此时客户端准备好接收返回结果了，那么 redis 中的 socket01 会产生一个 AE_WRITABLE 事件，同样压入队列中，
6. 事件分派器找到相关联的命令回复处理器，由命令回复处理器对 socket01 输入本次操作的一个结果，比如 ok，之后解除 socket01 的 AE_WRITABLE 事件与命令回复处理器的关联。

###### Redis为什么快？

- 基于内存，内存的读写速度非常快
- 单线程，保证了每个操作的原子性，省去了线程上下文切换的时间
- 非阻塞IO，内部采用采用epoll，epoll中的读、写、关闭、连接都转化了事件，利用epoll的IO多路复用特性，可以处理并发的连接。

###### Io多路复用



###### Redis持久化的方式

- RDB

为什么需要持久化？

Redis是基于内存的数据库，如果不想办法将存储在内存中的数据库状态保存在磁盘中，那么一旦服务器进程退出，服务器中的数据库状态也会消失不见，为此，Redis提供了RDB持久化功能，这个功能可以将Redis在内存中的数据库状态保存到磁盘中，避免数据意外丢失。RDB生成的RDB文件是一个经过压缩的二进制文件，通过该文件可以还原生成RDB文件时的数据库状态。

SAVE,BGSAVE命令的实现方式？

有两个Redis命令可以用于生成RDB文件，一个是SAVE，一个是BGSAVE。

SAVE会阻塞Redis服务器进程，知道RDB文件创建完毕，在创建期间，服务器不能处理任何命令请求。

而BGSAVE命令会派生出一个子进程，然后由子进程负责创建RDB文件，服务器进程继续处理请求。

RDB文件的载入工作是在服务器启动时自动执行的，所以Redis没有专门用来载入RDB文件的命令，只要Redis服务器在启动时检测到RDB文件存在，它就会自动载入RDB文件。，若有AOF会优先使用AOF，因为它的更新频率往往比RDB高。

- AOF

| appendfsync选项的值 |                     flushAppendOnlyFile                      |
| :-----------------: | :----------------------------------------------------------: |
|       always        |         将aof_buf缓存区中所有内容写入并同步到AOF文件         |
|      everysec       | 将aof_buf缓冲区中的所有内容写入到aof文件，如果上次同步aof文件的时间距离现在超出一秒，那么再次对aof文件进行同步，并且这个同步操作是由一个线程专门负责 |
|         no          |                只负责写，同步交由操作系统负责                |

通过保存Redis服务器所执行的写命令来记录数据库状态，服务器在启动时，就可以载入和执行AOF文件中保存的命令来还原服务器关闭之前的数据库状态。

实现原理：命令追加、文件写入、文件同步

命令追加：服务器在执行完一个写命令之后，会以协议格式将被执行的写命令追加到服务器状态的aof-buf缓冲区的末尾

文件写入与同步，fsync与fdatasync两个同步函数，可以强制让操作系统立即将缓存区中的数据写入到硬盘中。

###### Redis内存淘汰策略

- noeviction： 内存超过配置的时候会返回错误，不会删任何键
- allkeys-lru：删掉最久未使用的键
- volatile-lru:从设置了过期时间的键集合中删掉最久没有使用的键
- allkeys-random：从所有键中随机删掉一个
- volatile-random:从过期键的集合中随机删掉一个
- volatile-ttl：删掉在过期集合的键，并且优先选择存活时间较短的键
- allkeys-lfu:删掉使用频率最少的键
- volatile-lfu：从配置了过期时间的键中删掉使用频率最少的键

###### Redis优缺点

优点：

- 因为因为基于内存，因此读写性能优异
- 支持持久化，支持AOF和RDB两种持久化方式
- 支持事务，Redis的所有操作都是原子性的，同时Redis还支持对几个操作合并后的原子性执行。
- 数据结构丰富
- 支持主从复制，主机自动将数据同步到从机，可以进写读写分离

缺点：

- 受物理内存的限制，不能作为海量数据的高性能读写，适用于较小数据量的高性能操作和运算上。
- 主从机的宕机都会导致前端部分读写请求失败
- 主机宕机前若有部分数据未能及时同步到从机，切换IP后还会导致数据不一致的问题
- Redis不支持在线扩容。在系统上线时必须确保有足够的空间。

###### Redis跳表实现

![img](https://cdn.jsdelivr.net/gh/nanxi1234/nanxi1234.github.io/image/2021/20210919164335.webp)

![img](https://cdn.jsdelivr.net/gh/nanxi1234/nanxi1234.github.io/image/2021/20210919164417.webp)

![img](https://cdn.jsdelivr.net/gh/nanxi1234/nanxi1234.github.io/image/2021/20210919164435.webp)

每加一层索引，搜索的时间复杂度就降为原来的O（n/2），本质上是一种空间换时间的数据结构。能提高搜索效率。

时间复杂度logn，空间复杂度n。

- 插入数据

如果一直加不更新索引层，会造成两个索引节点的中间数据非常多，相当于退化成了单链表。但是如果要维护索引与原始链表大小之间的平衡，时间复杂度又会变成O（n），跳表为了避免每次插入/删除时对链表进行维护，实际相邻两层的链表之间的节点数上采用的是一种非严格的1/2倍的对应关系，

- 为什么选择跳表实现有序集合
- 哈希表是无序的，且只能查找单个 key，不适宜范围查找
- 实现简单，插入删除时只需要调整相邻两个节点的指针，不用旋转节点，效率会高一点
- 插入、删除、查找以及迭代输出有序序列这几个操作，红黑树也可以完成，时间复杂度跟跳表是一样的。但是，按照区间来查找数据这个操作，红黑树的效率没有跳表高（跳表只需要定位区间的起点，然后遍历就行了）
- Redis 选跳表实现有序集合，还有其他各种原因，比如代码实现相对简单些，且更加灵活，它可以通过改变索引构建策略，有效平衡执行效率和内存消耗

Map为什么用红黑树而不用链表？

- 跳表需要维护额外的多层链表，是空间换时间的做法，红黑树不用占用多余的空间

- HashMap的Entry并没有内在的排序关系，所以无法使用跳表，因为跳表要求存在排序关系

###### Redis的链表操作

当一个列表键包含了数量比较多的元素。又或者列表中包含的元素都是比较长的字符串时，Redis就会用链表作为列表键的底层实现。

lpush：插入

lrange:遍历

lpop:删除元素

lindex：按下标选中list中的元素

llen：查看list长度
