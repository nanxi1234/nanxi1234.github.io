---
title: 计网
tags:
 
---



##### OSI七层协议，五层网络协议，各层功能，各层协议

##### OSI七层模型

应用层、表示层、会话层、传输层、网络层、数据链路层、物理层

###### 五层体系结构

应用层、传输层、网络层、数据链路层和物理层

###### TCP/IP的体系协议

应用层、运输层、网络层、网路接口层

![image.png](https://cdn.jsdelivr.net/gh/nanxi1234/nanxi1234.github.io/image/2021/20210925202652.webp)

| OSI七层网络模型 | TCP/IP四层概念模型 | 对应网络协议 |
| :-------------: | :----------------: | :----------: |
|     应用层      |                    |  HTTP、FTP   |
|     表示层      |       应用层       |     FTP      |
|     会话层      |                    |  SMTP、DNS   |
|     传输层      |       传输层       |   TCP、UDP   |
|     网络层      |       网络层       |      IP      |
|   数据链路层    |     数据链路层     |     ATM      |
|     物理层      |                    |              |

- 应用层：各种应用程序协议
- 表示层：信息的语法语义以及它们的关联，如加密、转换翻译、压缩解压缩
- 会话层：不同机器上的用户之间建立以及管理会话
- 传输层：接受上一层的数据，在必要的时候把数据交给网络层，且保证这些数据段有效到达对端
- 网络层：控制子网的运行，如逻辑地址、分组传输、路由选择
- 数据链路层：物理寻址，同时将原始比特流转变为逻辑传输路线
- 物理层：机械、电子、定时接口通信道上的原始比特流传输

![img](https://cdn.jsdelivr.net/gh/nanxi1234/nanxi1234.github.io/image/2021/20210922194104.gif)

- 应用层

应用层协议是应用进程间的通信和交互的规则，应用层的协议包括HTTP（提供web文档的请求与传送）、SMTP（提供电子邮件报文的传输）、和FTP（提供两个端系统之间的文件传送）、DNS将域名转换成32比特的网络地址。

一个端系统的应用程序使用协议与另一个端系统中的应用程序交换信息分组，把这种位于应用层的信息分组称为报文。

- 运输层

运输层在应用程序端点之间传送应用层报文，有两种运输层协议：TCP\UDP。

- 网络层

负责将数据报的网络层分组从一台主机移动到另一个主机，具体功能包括寻址和路由选择使两终端系统能够互联并决定最佳路径、连接的建立、保持、终止等，它使运输层不需要了解网络中的数据传输与交换技术。IP协议就是在该层。

寻址：对网络层而言用IP地址来唯一标识互联网上的设备，网络层依靠IP地址进行相互通信。

路由：在同一个网络中的内部通信并不需要网络层设备，仅仅靠数据链路层就可以完成相互通信，对于不同的网络之间的相互通信则必须借助路由器等三层设备。

- 链路层

将分组从一个节点（主机或路由器）移动到路径的下一个节点，网络层将数据报下传给链路层，链路层沿路径将数据报传给下一个节点并把数据报上传给网络层。网络层将受到来自每个不同链路层协议的不同服务，链路层分组称为帧。

- 物理层

链路层的任务是将整个帧从一个网络元素移动到邻近的网络元素，而物理层的任务是将该帧中的比特从一个节点移动到下一个节点，这层的协议仍然是链路相关的，并且进一步与该链路的实际传输媒介相关。

##### tcp的三次握手和四次挥手，以及为什么。

![img](https://cdn.jsdelivr.net/gh/nanxi1234/nanxi1234.github.io/image/2021/20210922211808.png)

1. 刚开始客户端和服务端都是处于关闭的状态，而且服务器B端一直处于监听的状态，时刻监听是否有建立连接的请求。

2. 当有客户端需要建立连接的时候就会发送一个确定连接的报文，此报文是同步报文SYN = 1，并且会生成一个随机的序号seq = x，这是第一次握手。

3. 当服务端接收到请求连接报文时，会发送一个同步报文确定报文，此报文SYN = 1，并且ACK = 1，同时服务端也会随机生成seq = y，并将ack设置为x+1，回传给客户端。这是第二次握手。

4. 当客户端接受到服务端的ACK报文之后，会回复一个ACK确定报文，用于确定报文已经收到，此报文ACK = 1，seq = x+1,ack = y+1，这是第三次握手。

   这里有个点说明一下：大写的 ACK 表示报文的类型是确认报文，小写的 ack 是报文里面的确认号，这个确认号是上一次握手对方的 seq 值加 1 得到。

第一次握手：第一次握手是客户端发送同步报文到服务端，这个时候客户端是知道自己具备发送数据的能力的，但是不知道服务端是否有接收和发送数据的能力；

第二次握手：当服务端接收到同步报文后，回复确认同步报文，此时服务端是知道客户端具有发送报文的能力，并且知道自己具有接收和发送数据的能力，但是并不知道客户端是否有接收数据的能力；

第三次握手：当客户端收到服务端的确认报文后，知道服务端具备接收和发送数据的能力，但是此时服务端并不知道自己具有接收的能力，所以还需要发送一个确认报文，告知服务端自己是具有接收能力的。

当整个三次握手结束过后，客户端和服务端都知道自己和对方具备发送和接收数据的能力，随后整个连接建立就完成了，可以进行后续数据的传输了。

看到这里，如果大家理解了就会知道很明显，两次握手是不行的，因为服务端并不知道客户端是具备接收数据的能力，所以就不能成为面向连接的可靠的传输协议。就像我们上面提到的打电话的例子，也是为了双方能够正常的进行交流，只不过我们现实生活中不会那么严谨，并不是每次都这样，但是程序是不一样的。

###### 四次挥手

![img](https://cdn.jsdelivr.net/gh/nanxi1234/nanxi1234.github.io/image/2021/20210922211814.png)

三次握手是为了建立可靠的数据传输通道，四次挥手则是为了保证等数据完成的被接收完再关闭连接。既然提到需要保证数据完整的传输完，那就需要保证双方都达到关闭连接的条件才能断开。

第一次挥手客户端发起关闭连接的请求给服务端；

第二次挥手：服务端收到关闭请求的时候可能这个时候数据还没发送完，所以服务端会先回复一个确认报文，表示自己知道客户端想要关闭连接了，但是因为数据还没传输完，所以还需要等待；

close wait

第三次挥手：当数据传输完了，服务端会主动发送一个 FIN 报文，告诉客户端，表示数据已经发送完了，服务端这边准备关闭连接了。

第四次挥手：当客户端收到服务端的 FIN 报文过后，会回复一个 ACK 报文，告诉服务端自己知道了，再等待一会（2MSL，即两个报文最大存活时间）就关闭连接。

1. 为什么握手要三次，挥手却要四次呢？

   那是因为握手的时候并没有数据传输，所以服务端的 SYN 和 ACK 报文可以一起发送，但是挥手的时候有数据在传输，所以 ACK 和 FIN 报文不能同时发送，需要分两步，所以会比握手多一步。

2. 为什么客户端在第四次挥手后还会等待 2MSL？

等待 2MSL 是因为保证服务端接收到了 ACK 报文，因为网络是复杂的，很有可能 ACK 报文丢失了，如果服务端没接收到 ACK 报文的话，会重新发送 FIN 报文，只有当客户端等待了 2MSL 都没有收到重发的 FIN 报文时就表示服务端是正常收到了 ACK 报文，那么这个时候客户端就可以关闭了。

###### 如何处理TimeWait过多？

为什么需要TimeWait?

网络情况不好时，如果主动方无time_wait等待，关闭前个连接后，主动方与被动方又建立起新的连接，这时被动方重传过来的Fin包过来会直接影响新的TCP连接



1. 将请求头的头部的connection设置为keep-alive，保存存活一段时间
2. 修改sysctl.conf文件，修改以下几个参数：

- net.ipv4.tcp_tw_recycle = 1

开启这个配置后，内核会快速的回收处于Time_wait状态的socket连接

- net.ipv4.tcp_tw_refuse = 1（只适用主动发起连接的客户端）

开启后总是自己先关闭连接，关闭后又不断的重新连接对方，当连接被复用了之后，延迟或重发的数据包到达，根据timestamp时间戳判断，当新连接建立后，时间戳更新为最新的时间，当延迟的报文段到达后，如果其时间戳是小于当前连接，这时TCP就可以将这个报文段直接丢弃。

- net.ipv4.tcp_timestamp = 1

两个4字节的时间戳字段，第一个4字节字段用来保存发送该数据包的时间，第二个4字节字段用来保存最近一次接收对方发送到数据的时间。



###### HTTP 与HTTPS的区别

HTTP是一种超文本传输协议，用于在两端之间传输文字、图片、音频、视频等超文本数据的约定和规范。

HTTPS是比HTTP多了安全这个概念，实际上它是HTTP+TLS/SSL协议组合而成，而安全性的保证正是TSL/SSL所做的工作。

区别：

- HTTP是未经安全加密的协议，它的传输过程容易被攻击者监听，数据容易被窃取，发送方和接收方容易被伪造，而HTTPS是安全的协议，通过密钥交换算法+签名算法+对称加密算法+摘要算法解决这些问题。
- HTTP的默认端口80，HTTPS默认是443



##### TCP 拥塞控制

###### 滑动窗口

为了解决可靠传输以及包乱序的问题，TCP引入了滑动窗口的概念，在传输过程中，client和server协商接收窗口，再结合拥塞控制窗口cwnd计算滑动窗口swnd。在Linux中，滑动窗口cwnd是以包为单位。

滑动窗口包含4部分：

- 已收到ack确定的数据
- 已发还没有收到ack的
- 在窗口中还没有发出的（接受方还有空间）
- 窗口以外的数据（接受方没空间）

![img](https://cdn.jsdelivr.net/gh/nanxi1234/nanxi1234.github.io/image/2021/20210923143225.jpeg)

![img](https://cdn.jsdelivr.net/gh/nanxi1234/nanxi1234.github.io/image/2021/20210923143232.jpeg)

###### 包守恒原则

TCP维护一个发送窗口，估计当前网络链路上能容纳的数据包数量，在有数据可发的情况下，确定一个包就发出一个数据包，总是保持发送窗口大小的包在网络中流动。

传输的理想情况是要同时达到最大的吞吐量和最小的往返延迟，要实现，必须同时满足两个条件：

- 以链路瓶颈带宽发包（带宽利用率最高）
- 保证链路中没有缓存队列

###### TCP拥塞控制

- TCP所采用的方法是让每一个发送方根据所感知到的网络阻塞程度来限制其能向连接发送流量的速率
- TCP发送方跟踪一个拥塞窗口cwnd，它对一个TCP发送方能向网络中发送流量的速率进行了限制。在一个发送方中未被确定的数据量不会超过cwnd(拥塞窗口)和rwnd（接收窗口）中的最小值
- 将一个TCP发送方的丢包事件定义为：要么出现超时，要么收到来自接受方的三个冗余ACK，而丢包事件在发送方看来，是路径上出现了拥塞的一种指示。
- TCP使用确定来触发它的窗口调节长度
- TCP遵从下列指导性原则使发送方确定它应当发送的速率：

      1. 一个丢死的报文端意味着阻塞，应当适当降低TCP发送方的速率
         2. 一个确定报文段指示着一种顺利的信号，应当增加发送方的速率
         3. 带宽探测：TCP发送方的行为是一个试探的过程，假如增加/降低了发送方的速率，TCP发送方会接着进行探测，从而考虑是否进一步的增加/降低。

###### 慢启动

- TCP连接开始时，cwnd的值通常被设为一个较小值，这使初始发送速率大约为MSS/RTT，但对于TCP发送方而言，可用带宽可能远大于MSS/RTT，因此TCP发送方希望尽可能快地找到可用带宽的数量。
- 在慢启动状态，cwnd的值以一个MSS开始并且每当传输的报文段首次被确定就增加一个MSS，每经过一个RTT，发送速率就翻倍。TCP发送速率呈现指数级增长。

![image-20210428103922153](https://cdn.jsdelivr.net/gh/nanxi1234/nanxi1234.github.io/image/2021/20210923153555.png)

有下列三种改变状态的情况：

- 如果存在超时指示的丢包事件，将cwnd置为1并重新开始慢启动过程，将第二个状态变量的值ssthresh（慢启动阈值）设置为cwnd/2。相当于用ssthresh标记一下可能快要出现超时的位置。
- 当cwnd的值等于ssthresh时，结束慢启动并将TCP转移到拥塞避免模式。
- 如果检测到三个冗余ACK，TCP反应相对不那么剧烈，而是将cwnd的值减半，再为三个冗余ACK加上三个MSS（最大报文段大小，TCP的报文段中的数据部分的最大字节数），再将ssthresh的值记录为cwnd的一半，最终进入快速恢复状态。

###### 拥塞避免

- 进入拥塞避免说明cwnd的值是上次遇到拥塞的值的一半，这意味着我们距离拥塞并不远，因此TCP不再选择每过一个RTT（往返时间）将将cwnd的值翻倍，而是每次（一个RTT）将cwnd的值增加一个MSS。

- 有下列两种改变状态的情况

  - **当出现超时丢包时，与慢启动情况一样，cwnd 的值置为一个 MSS，ssthresh 的值被更新为 cwnd 值的一半。最终进入慢启动状态。**
  - **当出现三个冗余 ACK 事件的丢包时，TCP 反应相对不那么剧烈，而是将 cwnd 的值减半，再为三个冗余 ACK 加上三个 MSS。再将 ssthresh 的值记录为 cwnd 的一半。最终进入快速恢复状态。**

###### 快速重传算法

有时拥塞比较轻微，只有少量包丢失，后续的包能够正常到达，当后续的包到达接受方时，接收方会发现其Seq号比期望的大，所以它每收到一个包就Ack一次期望的Seq号，以此提醒发送方重传。当发送方收到3个或以上重复确认（Dup Ack）时，就意识到相应的包已经丢了，从而立即重传它。这个过程称为快速重传。

为什么要规定凑满3个呢？这是因为网络包有时会乱序，乱序的包一样会触发重复的Ack，但是为了乱序而重传没有必要。由于一般乱序的距离不会相差太大，比如2号包也许会跑到4号包后面，但不太可能跑到6号包后面，所以限定成3个或以上可以在很大程度上避免因乱序而触发快速重传。

如果2号和3号包都丢失了，但是后面4，5，6，7号都正常收到了，并触发了三次Ack2。在重传了2号包之后该传哪个包那，是全部需要重传还是只传2号包？

为了解决这种问题，TCP在发送重复的Ack包的时候，会告诉接收方收到的已经收到包的序号，如下图

<center><img src="https://cdn.jsdelivr.net/gh/nanxi1234/nanxi1234.github.io/image/2021/20210923162158.jpeg" alt="img" style="zoom:67%;" /></center>

###### 快速恢复

<center><img src="https://cdn.jsdelivr.net/gh/nanxi1234/nanxi1234.github.io/image/2021/20210923155741.jpg" alt="826489eb1561bb6a70dc219dcc67607" style="zoom:80%;" /></center>

设计背景：当数据在网络中发生丢失时，由于还有部分数据还在互联网中向接收方流动，TCP协议并不想突然执行慢启动（cwnd设置为1）减少数据流的发送，这样由于网络的短暂波动影响了整条链路的数据发送。

实现过程：

- 当收到重复3次的ack时，ssthresh设置为cwnd的一半，并重传丢失的报文，同时设置cwnd = ssthresh + 3 * MSS

- 同时，由于还有多个报文还在网络中传递，所以接收端还会继续的发送ack报文，发送端每收到一个ack，就将cwnd加一，并且发送一个新的分组。
- 当接收端收到重传的数据包时，将会回复一个ack，这个ack不仅仅是对重传包的确认，而是对这一段时间内收到的所有报文进行确认。
- 若ssthresh > cwnd 此时TCP进行拥塞避免算法。

<center><img src="https://cdn.jsdelivr.net/gh/nanxi1234/nanxi1234.github.io/image/2021/20210923191643.png" alt="image-20210627222344287" style="zoom:80%;" /></center>

###### HTTP状态码

| 状态码 |             含义             |
| :----: | :--------------------------: |
|  1xx   |        请求正在被处理        |
|  2xx   |         请求成功处理         |
|  3xx   |  请求需要附加操作，如重定向  |
|  4xx   | 客户端出错导致请求无法被处理 |
|  5xx   |        服务端处理出错        |

- 100 continue 继续，客户端继续其请求
- 200 OK 请求成功，一般用于GET与POST请求
- 307 临时重定向 使用GET请求重定向
- 400 客户端请求的语法错误，服务器无法理解
- 401 请求要求用户的身份认证
- 403 服务器理解客户端的请求但是拒绝此请求
- 404 服务器无法根据客户端的请求找到资源
- 408 服务器等待客户端发送的请求时间过长，超时
- 500 服务器内部错误，无法完成请求
- 504 充当网关或代理的服务器，未及时从远端服务器获取请求

##### HTTP报文格式

###### 请求报文

HTTP请求报文的**第一行叫做请求行**，其**后继的行叫做首部行**，请求行有三个字段：**方法字段、URL字段和HTTP版本字段**，方法字段包括GET\POST\HEAD\PUT\DELETE。在URL字段带有请求对象的标识。

首部行指明对象所在的主机

<center><img src="https://cdn.jsdelivr.net/gh/nanxi1234/nanxi1234.github.io/image/2021/20210923195539.jpg" alt="7f78af512ee7b3a46fb3d75b3b9255e" style="zoom:67%;" /></center>

GET与POST的区别：

- 使用GET方法时实体体为空，使用POST方法时才使用该实体体。

- 当用户提交表单时，HTTP客户常用POST方法，使用POST报文时，用户仍可以向服务器请求一个Web页面，但Web页面的特定内容依赖于用户在表单字段中输入的内容，当方法字段的值为POST时，则实体类中包含的就是用户在表单字段中的输入值。
- GET方法在所请求的URL中包含输入的数据。



- HEAD：当服务器收到一个HEAD请求时，将会使用一个HTTP报文进行响应，但是不返回请求对象
- PUT：允许用户上传对象到指定的Web服务器上指定的路径
- DELETE：允许用户或者应用程序删除Web服务器上的对象



###### 响应报文

![4f042b484a821b422ad493ee835e585](https://cdn.jsdelivr.net/gh/nanxi1234/nanxi1234.github.io/image/2021/20210923201441.jpg)



###### COOKIE 和 SESSION 的区别

HTTP请求是无状态的，就是不知道这一次的请求和上一次请求是否有关系，比如登陆一个系统的时候，验证用户名密码之后，打开系统各个界面的时候就不用再登录了，实现这个需要用到Cookie和Session.

Cookie由服务器生成，发送给浏览器，由浏览器保存，是下一次请求同一网站会把cookie发送给服务器。保存用户信息的一种机制，每种浏览器的大小都会有一些差异，一般不超过4kb。

Session是在服务端保存，可以用于记录客户的状态，比如我们常用Session保存客户的基本信息、权限信息等；用户第一次登录之后，服务器就会创建一个session，浏览器再次访问时，只需从Session中查找该客户的信息就行了。

Session机制的缺点：分布式环境下会导致Session的失效

- session与cookie区别？

1. Cookie在客户端，Session在服务端
2. Cookie因为放在浏览器中，他人可以通过分析放在本地的Cookie进行Cookie欺骗，所以Cookie的安全性一般，而session是安全的
3. 单个Cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个Cookie，而session则存储在服务端，没有限制
4. Session会在一定时间保存在服务器上，当访问量增加时，会比较占用服务器的性能，而cookie则不会
5. 会话机制不同：session是一种服务端机制，用键值对的结构来保存信息，而cookie是服务器存储在本地计算机上的小块文本，并随着每个请求送到同一服务器。

###### 输入一个域名enter发生的事情

- 查看浏览器缓存和本机缓存中有没有这个网址对应的IP地址，如果有直接获取

- 如果没有则根据输入的域名通过DNS（主机名到IP地址转换的目录服务，运行在UDP之上，使用53号端口）去查IP地址

1. 首先浏览器从URL中提取出主机名，并将主机名传给DNS应用的客户端
2. 客户端向DNS服务器发送一个包含主机名的IP地址
3. 本地的DNS服务器会接收到请求，会在本地先查询缓存中有没有当前域名和IP的映射关系，如果有直接返回IP信息，如果没有，则会依次对根DNS服务器、顶级DNS服务器、权威DNS服务器发起请求，最终获得IP地址。

- HTTP请求

1. 然后浏览器会构建并发送Http请求，HTTP请求报文的格式包括请求行、首部行、空行、实体体，其中请求行包括请求方法、请求URL、Http版本号。
2. 在发送HTTP请求时，会先查询浏览器缓存（分为强缓存和协商缓存），会先查询缓存首先会根据http的首部行信息来判断是否存有强缓存（缓存是根据返回头中的 `Expires` 或者 `Cache-Control` 两个字段来控制的，都是表示资源的缓存有效时间），以及是否过期，如果有强缓存且未过期则命中，不会再发送给服务器，如果强缓存没命中，就向服务器发送请求，请求中的head首部行中会带有浏览器最后请求该资源的时间和一个资源检验码（使用资源修改时间、资源大小等信息生成），服务器收到请求后会判断协商缓存是否过期，如果过期则返回新的资源信息，如果没过期则返回304状态码，表示资源未更新，可以使用缓存中的资源。

- TCP --->网络层连接:TCP三次握手
- 网络层IP协议查询MAC地址

1. IP协议的作用是把TCP分割好的各种数据包封装到IP包里面传送给接收方，而要保证确实能传到接受方还需要接收方的MAC地址，也就是物理地址，通过ARP协议将IP地址解析为对应的MAC地址，当通信的双方不在同一个局域网时需要多次中转才能到达最终的目标，在中转的过程中需要通过下一个中转站的MAC地址来搜索下一个中转目标

- 数据到达链路层

1. 在找到对方的MAC地址后，已被封装好的IP包再被封装到数据链路层的数据帧结构中，将数据发送到数据链路层传输，再通过物理层的比特流送出去，发送请求结束。
2. （可不用记）这些分层的意义在于分工合作，数据链路层通过 CSMA/CD 协议保证了相邻两台主机之间的数据报文传递，而网络层的 IP 数据包通过不同子网之间的路由器的路由算法和路由转发，保证了互联网上两台遥远主机之间的点对点的通讯，不过这种传输是不可靠，于是可靠性就由传输层的 TCP 协议来保证，TCP 通过慢开始，乘法减小等手段来进行流量控制和拥塞避免，同时提供了两台遥远主机上进程到进程的通信，最终保证了 HTTP 的请求头能够被远方的服务器上正在监听的 HTTP 服务器进程收到，终于，数据包在跳与跳之间被拆了又封装，在子网与子网之间被转发了又转发，最后进入了服务器的操作系统的缓冲区，服务器的操作系统由此给正在被阻塞住的 accept 函数一个返回，将他唤醒。

- 服务器响应

  判断协商缓存是否过期，如果命中，则服务器返回 304 状态码，并且不会返回资源内容，浏览器会直接从缓存获取；否则服务器最终会返回资源的实际内容，并更新 header 中的相关缓存字段。如果过期了则返回最新的资源。

- 页面渲染

1. 浏览器收到响应后首先会根据返回的响应报文里的状态码做出判断，如果以1开头表示秦求正在处理中，以2开头表示请求处理成功，3开头表示需要附加操作比如重定向，4开头表示客户端的请求无法被处理，5开头说明服务器处理错误，最终得到文件之后进行TCP四次挥手，然后对它对其进行解析，渲染，生成页面。



HTTPS



###### 重定向

![查缺补漏：一文看懂HTTP请求流程，不信你还不会](https://cdn.jsdelivr.net/gh/nanxi1234/nanxi1234.github.io/image/2021/20210925202537.jpeg)

状态 301 就是告诉浏览器，我需要重定向到另外一个网址，而需要重定向的网址正是包含在响应头的 Location 字段中，接下来，浏览器获取 Location 字段中的地址，并使用该地址重新导航，这就是一个完整重定向的执行流程。
