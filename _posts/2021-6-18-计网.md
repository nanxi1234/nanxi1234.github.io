---
title: 计网
tags:
 
---



##### OSI七层协议，五层网络协议，各层功能，各层协议

##### OSI七层模型

应用层、表示层、会话层、传输层、网络层、数据链路层、物理层

###### 五层体系结构

应用层、传输层、网络层、数据链路层和物理层

###### TCP/IP的体系协议

应用层、运输层、网络层、网路接口层

| OSI七层网络模型 | TCP/IP四层概念模型 | 对应网络协议 |
| :-------------: | :----------------: | :----------: |
|     应用层      |                    |  HTTP、FTP   |
|     表示层      |       应用层       |     FTP      |
|     会话层      |                    |  SMTP、DNS   |
|     传输层      |       传输层       |   TCP、UDP   |
|     网络层      |       网络层       |      IP      |
|   数据链路层    |     数据链路层     |     ATM      |
|     物理层      |                    |              |

- 应用层：各种应用程序协议
- 表示层：信息的语法语义以及它们的关联，如加密、转换翻译、压缩解压缩
- 会话层：不同机器上的用户之间建立以及管理会话
- 传输层：接受上一层的数据，在必要的时候把数据交给网络层，且保证这些数据段有效到达对端
- 网络层：控制子网的运行，如逻辑地址、分组传输、路由选择
- 数据链路层：物理寻址，同时将原始比特流转变为逻辑传输路线
- 物理层：机械、电子、定时接口通信道上的原始比特流传输

![img](https://cdn.jsdelivr.net/gh/nanxi1234/nanxi1234.github.io/image/2021/20210922194104.gif)

- 应用层

应用层协议是应用进程间的通信和交互的规则，应用层的协议包括HTTP（提供web文档的请求与传送）、SMTP（提供电子邮件报文的传输）、和FTP（提供两个端系统之间的文件传送）、DNS将域名转换成32比特的网络地址。

一个端系统的应用程序使用协议与另一个端系统中的应用程序交换信息分组，把这种位于应用层的信息分组称为报文。

- 运输层

运输层在应用程序端点之间传送应用层报文，有两种运输层协议：TCP\UDP。

- 网络层

负责将数据报的网络层分组从一台主机移动到另一个主机，具体功能包括寻址和路由选择使两终端系统能够互联并决定最佳路径、连接的建立、保持、终止等，它使运输层不需要了解网络中的数据传输与交换技术。IP协议就是在该层。

寻址：对网络层而言用IP地址来唯一标识互联网上的设备，网络层依靠IP地址进行相互通信。

路由：在同一个网络中的内部通信并不需要网络层设备，仅仅靠数据链路层就可以完成相互通信，对于不同的网络之间的相互通信则必须借助路由器等三层设备。

- 链路层

将分组从一个节点（主机或路由器）移动到路径的下一个节点，网络层将数据报下传给链路层，链路层沿路径将数据报传给下一个节点并把数据报上传给网络层。网络层将受到来自每个不同链路层协议的不同服务，链路层分组称为帧。

- 物理层

链路层的任务是将整个帧从一个网络元素移动到邻近的网络元素，而物理层的任务是将该帧中的比特从一个节点移动到下一个节点，这层的协议仍然是链路相关的，并且进一步与该链路的实际传输媒介相关。

##### tcp的三次握手和四次挥手，以及为什么。

![img](https://cdn.jsdelivr.net/gh/nanxi1234/nanxi1234.github.io/image/2021/20210922211808.png)

1. 刚开始客户端和服务端都是处于关闭的状态，而且服务器B端一直处于监听的状态，时刻监听是否有建立连接的请求。

2. 当有客户端需要建立连接的时候就会发送一个确定连接的报文，此报文是同步报文SYN = 1，并且会生成一个随机的序号seq = x，这是第一次握手。

3. 当服务端接收到请求连接报文时，会发送一个同步报文确定报文，此报文SYN = 1，并且ACK = 1，同时服务端也会随机生成seq = y，并将ack设置为x+1，回传给客户端。这是第二次握手。

4. 当客户端接受到服务端的ACK报文之后，会回复一个ACK确定报文，用于确定报文已经收到，此报文ACK = 1，seq = x+1,ack = y+1，这是第三次握手。

   这里有个点说明一下：大写的 ACK 表示报文的类型是确认报文，小写的 ack 是报文里面的确认号，这个确认号是上一次握手对方的 seq 值加 1 得到。

第一次握手：第一次握手是客户端发送同步报文到服务端，这个时候客户端是知道自己具备发送数据的能力的，但是不知道服务端是否有接收和发送数据的能力；

第二次握手：当服务端接收到同步报文后，回复确认同步报文，此时服务端是知道客户端具有发送报文的能力，并且知道自己具有接收和发送数据的能力，但是并不知道客户端是否有接收数据的能力；

第三次握手：当客户端收到服务端的确认报文后，知道服务端具备接收和发送数据的能力，但是此时服务端并不知道自己具有接收的能力，所以还需要发送一个确认报文，告知服务端自己是具有接收能力的。

当整个三次握手结束过后，客户端和服务端都知道自己和对方具备发送和接收数据的能力，随后整个连接建立就完成了，可以进行后续数据的传输了。

看到这里，如果大家理解了就会知道很明显，两次握手是不行的，因为服务端并不知道客户端是具备接收数据的能力，所以就不能成为面向连接的可靠的传输协议。就像我们上面提到的打电话的例子，也是为了双方能够正常的进行交流，只不过我们现实生活中不会那么严谨，并不是每次都这样，但是程序是不一样的。

###### 四次挥手

![img](https://cdn.jsdelivr.net/gh/nanxi1234/nanxi1234.github.io/image/2021/20210922211814.png)

三次握手是为了建立可靠的数据传输通道，四次挥手则是为了保证等数据完成的被接收完再关闭连接。既然提到需要保证数据完整的传输完，那就需要保证双方都达到关闭连接的条件才能断开。

第一次挥手客户端发起关闭连接的请求给服务端；

第二次挥手：服务端收到关闭请求的时候可能这个时候数据还没发送完，所以服务端会先回复一个确认报文，表示自己知道客户端想要关闭连接了，但是因为数据还没传输完，所以还需要等待；

第三次挥手：当数据传输完了，服务端会主动发送一个 FIN 报文，告诉客户端，表示数据已经发送完了，服务端这边准备关闭连接了。

第四次挥手：当客户端收到服务端的 FIN 报文过后，会回复一个 ACK 报文，告诉服务端自己知道了，再等待一会（2ms）就关闭连接。

1. 为什么握手要三次，挥手却要四次呢？

   那是因为握手的时候并没有数据传输，所以服务端的 SYN 和 ACK 报文可以一起发送，但是挥手的时候有数据在传输，所以 ACK 和 FIN 报文不能同时发送，需要分两步，所以会比握手多一步。

2. 为什么客户端在第四次挥手后还会等待 2MSL？

等待 2MSL 是因为保证服务端接收到了 ACK 报文，因为网络是复杂的，很有可能 ACK 报文丢失了，如果服务端没接收到 ACK 报文的话，会重新发送 FIN 报文，只有当客户端等待了 2MSL 都没有收到重发的 FIN 报文时就表示服务端是正常收到了 ACK 报文，那么这个时候客户端就可以关闭了。
